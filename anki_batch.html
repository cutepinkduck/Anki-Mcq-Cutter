<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ANKI MCQ CUTTER</title>

    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Pretendard:wght@400;700;900&display=swap');

        body {
            font-family: 'Pretendard', sans-serif;
        }

        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }

        .custom-scrollbar::-webkit-scrollbar-track {
            background: transparent;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #e2e8f0;
            border-radius: 20px;
            border: 2px solid white;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #cbd5e1;
        }

        .input-group label {
            font-size: 10px;
            font-weight: bold;
            color: #64748b;
            margin-bottom: 2px;
            display: block;
        }

        .input-group input,
        .input-group select,
        .input-group textarea {
            width: 100%;
            padding: 6px 8px;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            font-size: 12px;
            color: #334155;
            outline: none;
            transition: all 0.2s;
        }

        .input-group input:focus,
        .input-group select:focus,
        .input-group textarea:focus {
            border-color: #6366f1;
            ring: 2px;
            ring-color: #e0e7ff;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        .modal-overlay {
            animation: fadeIn 0.2s ease-out;
        }

        .cursor-zoom-in {
            cursor: zoom-in;
        }

        .cursor-zoom-out {
            cursor: zoom-out;
        }

        .guard-active {
            border: 3px solid #10b981 !important;
            box-shadow: 0 0 30px rgba(16, 185, 129, 0.3);
            background-color: #f0fdf4;
        }

        button:disabled {
            cursor: not-allowed;
            opacity: 0.5;
            filter: grayscale(100%);
        }

        .processed-overlay {
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(2px);
            border: 4px solid #10b981;
        }
    </style>
</head>

<body class="bg-slate-50">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo, useCallback, memo, Component } = React;

        const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        // --- [IndexedDB Helper] ---
        const DB_NAME = 'AnkiTurboDB_v1';
        const STORE_RESULTS = 'results';

        const dbPromise = new Promise((resolve, reject) => {
            const req = indexedDB.open(DB_NAME, 1);
            req.onupgradeneeded = (e) => {
                const db = e.target.result;
                if (!db.objectStoreNames.contains(STORE_RESULTS)) db.createObjectStore(STORE_RESULTS);
            };
            req.onsuccess = () => resolve(req.result);
            req.onerror = () => reject(req.error);
        });

        const idbSave = async (key, val) => {
            const db = await dbPromise;
            return new Promise((resolve, reject) => {
                const tx = db.transaction(STORE_RESULTS, 'readwrite');
                tx.objectStore(STORE_RESULTS).put(val, key);
                tx.oncomplete = () => resolve();
                tx.onerror = () => reject(tx.error);
            });
        };

        const idbLoad = async (key) => {
            const db = await dbPromise;
            return new Promise((resolve, reject) => {
                const tx = db.transaction(STORE_RESULTS, 'readonly');
                const req = tx.objectStore(STORE_RESULTS).get(key);
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject(req.error);
            });
        };
        // -------------------------

        class ErrorBoundary extends Component {
            constructor(props) { super(props); this.state = { hasError: false, error: null }; }
            static getDerivedStateFromError(error) { return { hasError: true, error }; }
            componentDidCatch(error, errorInfo) {
                if (error.message && error.message.includes('ResizeObserver')) {
                    this.setState({ hasError: false, error: null });
                    return;
                }
                console.error("Non-fatal Error:", error);
            }
            render() {
                if (this.state.hasError) {
                    return (
                        <div className="relative">
                            {this.props.children}
                            <div className="fixed inset-0 z-[100] bg-black/50 flex items-center justify-center backdrop-blur-sm animate-fadeIn">
                                <div className="bg-white p-8 rounded-2xl shadow-2xl text-center max-w-md border-4 border-rose-500">
                                    <h2 className="text-2xl font-black text-rose-600 mb-2">âš ï¸ ì‹œìŠ¤í…œ ì¼ì‹œ ì •ì§€</h2>
                                    <p className="text-slate-600 mb-6 font-bold text-sm">ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.<br />ë°ì´í„°ëŠ” ì•ˆì „í•©ë‹ˆë‹¤.</p>
                                    <button onClick={() => this.setState({ hasError: false })} className="bg-indigo-600 text-white px-8 py-3 rounded-xl font-bold hover:scale-105 transition-transform shadow-lg">ì‘ì—… í™”ë©´ìœ¼ë¡œ ë³µê·€ (Resume)</button>
                                </div>
                            </div>
                        </div>
                    );
                }
                return this.props.children;
            }
        }

        const LucideIcon = memo(({ name, size = 16, className = "" }) => {
            const iconRef = useRef(null);
            useEffect(() => {
                if (window.lucide && iconRef.current) {
                    iconRef.current.innerHTML = `<i data-lucide="${name}"></i>`;
                    window.lucide.createIcons({
                        root: iconRef.current,
                        name: name,
                        attrs: { width: size, height: size, class: className }
                    });
                }
            }, [name, size, className]);
            return <span ref={iconRef} style={{ display: 'inline-flex' }}></span>;
        });

        // [NEW] ê¾¹ ëˆ„ë¥´ê¸° ì§€ì› ë²„íŠ¼ ì»´í¬ë„ŒíŠ¸
        const HoldButton = memo(({ onAction, className, children, shiftMultiplier = 5 }) => {
            const intervalRef = useRef(null);
            const isHoldingRef = useRef(false);

            const startHold = (e) => {
                e.preventDefault();
                e.stopPropagation();
                const multiplier = e.shiftKey ? shiftMultiplier : 1;
                onAction(multiplier);
                isHoldingRef.current = true;

                // 200ms í›„ë¶€í„° ì—°ì† ì‹¤í–‰ (ì´ˆê¸° ë”œë ˆì´)
                setTimeout(() => {
                    if (!isHoldingRef.current) return;
                    intervalRef.current = setInterval(() => {
                        if (isHoldingRef.current) onAction(multiplier);
                    }, 80); // 80ms ê°„ê²©ìœ¼ë¡œ ì—°ì† ì‹¤í–‰
                }, 200);
            };

            const stopHold = (e) => {
                e?.stopPropagation();
                isHoldingRef.current = false;
                if (intervalRef.current) {
                    clearInterval(intervalRef.current);
                    intervalRef.current = null;
                }
            };

            useEffect(() => {
                // ë§ˆìš°ìŠ¤ê°€ ìœˆë„ìš° ë°–ìœ¼ë¡œ ë‚˜ê°€ë„ ì •ì§€
                window.addEventListener('mouseup', stopHold);
                window.addEventListener('mouseleave', stopHold);
                return () => {
                    window.removeEventListener('mouseup', stopHold);
                    window.removeEventListener('mouseleave', stopHold);
                    if (intervalRef.current) clearInterval(intervalRef.current);
                };
            }, []);

            return (
                <button
                    className={className}
                    onMouseDown={startHold}
                    onMouseUp={stopHold}
                    onMouseLeave={stopHold}
                    onTouchStart={startHold}
                    onTouchEnd={stopHold}
                >
                    {children}
                </button>
            );
        });

        const ResultItem = memo(({ item, pageNum, isSelected, isEditing, isLoading, tempImg, onToggleSelect, onStartEdit, onUpdateBbox, onEndEdit, onDelete, onPreview }) => {
            const displayImg = (isEditing && tempImg) ? tempImg : item.img;
            const isHighResLoading = item.isHighResLoading;

            return (
                <div onClick={() => onToggleSelect(item.fName)} className={`p-3 rounded-2xl border flex flex-col gap-2 shadow-sm hover:shadow-md transition-all relative cursor-pointer ${isSelected ? 'ring-2 ring-indigo-500 bg-indigo-50' : (item.type === 'question' ? 'bg-white border-indigo-100' : 'bg-slate-100 border-slate-200')}`}>
                    {isLoading && (
                        <div className="absolute inset-0 z-50 bg-white/60 backdrop-blur-[2px] flex flex-col items-center justify-center rounded-2xl animate-fadeIn">
                            <LucideIcon name="loader-2" size={32} className="text-indigo-600 animate-spin mb-2" />
                            <span className="text-[10px] font-bold text-indigo-900">ë¡œë”© ì¤‘...</span>
                        </div>
                    )}

                    {isHighResLoading && (
                        <div className="absolute top-2 right-2 z-20 bg-indigo-600/90 text-white text-[9px] px-2 py-1 rounded-full flex items-center gap-1 animate-pulse shadow-lg">
                            <LucideIcon name="wand-2" size={10} className="animate-spin" /> ê³ í™”ì§ˆ ë³€í™˜
                        </div>
                    )}

                    <div className="flex justify-between items-center">
                        <span className={`text-[10px] font-black uppercase px-2 py-0.5 rounded ${item.type === 'question' ? 'bg-indigo-100 text-indigo-600' : 'bg-slate-200 text-slate-500'}`}>{item.type === 'question' ? `Q.${item.number}` : `SOL.${item.number}`}</span>
                        {/* ì±•í„°ëª… ê°€ë¦¼ í˜„ìƒ í•´ê²°ì„ ìœ„í•´ ë²„íŠ¼ ì´ë™ í›„ ë„ˆë¹„ í™•ì¥ */}
                        <span className="text-[9px] text-slate-500 font-bold truncate max-w-[180px] text-right" title={item.chapter}>{item.chapter}</span>
                    </div>

                    <div className="h-64 w-full rounded-xl border border-slate-300 overflow-hidden cursor-zoom-in relative group flex items-center justify-center bg-slate-200/60" onClick={(e) => { e.stopPropagation(); onPreview(displayImg); }} title="í´ë¦­í•˜ì—¬ í™•ëŒ€">
                        {/* ë²„íŠ¼ì„ ì´ë¯¸ì§€ ì˜ì—­ ë‚´ë¶€ ìš°ìƒë‹¨ìœ¼ë¡œ ì´ë™ (í…ìŠ¤íŠ¸ ì•ˆ ê°€ë¦¬ê²Œ) */}
                        {!isEditing && (
                            <div className="absolute top-2 right-2 z-20 flex gap-1 opacity-100 transition-opacity">
                                <button onClick={(e) => { e.stopPropagation(); onStartEdit(pageNum, item.originalItemIndex, item.bbox); }} className="bg-white/90 p-1.5 rounded-full hover:bg-indigo-500 hover:text-white transition shadow-md border border-slate-200 backdrop-blur-sm" title="ìë¥´ê¸° ìˆ˜ì •"><LucideIcon name="scissors" size={14} /></button>
                                <button onClick={(e) => { e.stopPropagation(); onDelete(pageNum, item.originalItemIndex); }} className="bg-white/90 p-1.5 rounded-full hover:bg-rose-500 hover:text-white transition shadow-md border border-slate-200 backdrop-blur-sm" title="ì‚­ì œ"><LucideIcon name="trash-2" size={14} /></button>
                            </div>
                        )}

                        <div className="absolute inset-0 bg-black/0 group-hover:bg-black/10 transition-colors flex items-center justify-center opacity-0 group-hover:opacity-100 z-10 pointer-events-none"><LucideIcon name="zoom-in" className="text-white drop-shadow-md" size={24} /></div>
                        <img src={displayImg} className="max-w-full max-h-full object-contain shadow-lg bg-white" />
                    </div>

                    {isEditing && (
                        <div className="absolute inset-0 z-20 flex flex-col justify-between p-1 pointer-events-none bg-black/5 rounded-2xl" onClick={(e) => e.stopPropagation()}>
                            <div className="w-full flex justify-center gap-1 pointer-events-auto">
                                <HoldButton onAction={(mult) => onUpdateBbox('top', 10 * mult)} className="bg-slate-800/80 hover:bg-slate-700 text-white px-2 py-1 rounded text-[10px]" shiftMultiplier={5}>â¬†ï¸+</HoldButton>
                                <HoldButton onAction={(mult) => onUpdateBbox('top', -5 * mult)} className="bg-slate-800/80 hover:bg-slate-700 text-white px-2 py-1 rounded text-[10px]" shiftMultiplier={5}>â¬†ï¸-</HoldButton>
                            </div>
                            <div className="flex w-full justify-between flex-1 items-center px-1 pointer-events-auto">
                                <div className="flex flex-col gap-1">
                                    <HoldButton onAction={(mult) => onUpdateBbox('left', 10 * mult)} className="bg-slate-800/80 hover:bg-slate-700 text-white px-2 py-1 rounded text-[10px]" shiftMultiplier={5}>â¬…ï¸+</HoldButton>
                                    <HoldButton onAction={(mult) => onUpdateBbox('left', -5 * mult)} className="bg-slate-800/80 hover:bg-slate-700 text-white px-2 py-1 rounded text-[10px]" shiftMultiplier={5}>â¬…ï¸-</HoldButton>
                                </div>
                                <button onClick={(e) => { e.stopPropagation(); onEndEdit(); }} className="bg-indigo-600/90 hover:bg-indigo-500 text-white px-3 py-1.5 rounded-full text-[10px] font-bold shadow-lg pointer-events-auto">ì™„ë£Œ</button>
                                <div className="flex flex-col gap-1">
                                    <HoldButton onAction={(mult) => onUpdateBbox('right', 10 * mult)} className="bg-slate-800/80 hover:bg-slate-700 text-white px-2 py-1 rounded text-[10px]" shiftMultiplier={5}>â¡ï¸+</HoldButton>
                                    <HoldButton onAction={(mult) => onUpdateBbox('right', -5 * mult)} className="bg-slate-800/80 hover:bg-slate-700 text-white px-2 py-1 rounded text-[10px]" shiftMultiplier={5}>â¡ï¸-</HoldButton>
                                </div>
                            </div>
                            <div className="w-full flex justify-center gap-1 pointer-events-auto">
                                <HoldButton onAction={(mult) => onUpdateBbox('bottom', 10 * mult)} className="bg-slate-800/80 hover:bg-slate-700 text-white px-2 py-1 rounded text-[10px]" shiftMultiplier={5}>â¬‡ï¸+</HoldButton>
                                <HoldButton onAction={(mult) => onUpdateBbox('bottom', -5 * mult)} className="bg-slate-800/80 hover:bg-slate-700 text-white px-2 py-1 rounded text-[10px]" shiftMultiplier={5}>â¬‡ï¸-</HoldButton>
                            </div>
                        </div>
                    )}

                    {isSelected && <div className="absolute top-2 left-2 text-indigo-500"><LucideIcon name="check-circle" size={20} className="fill-white" /></div>}
                </div>
            );
        }, (prev, next) => {
            const pb = prev.item.bbox || [];
            const nb = next.item.bbox || [];
            const isBboxSame = pb.length === nb.length && pb[0] === nb[0] && pb[1] === nb[1] && pb[2] === nb[2] && pb[3] === nb[3];

            const isContentSame =
                prev.item.fName === next.item.fName &&
                prev.item.img === next.item.img &&
                prev.tempImg === next.tempImg &&
                prev.item.isHighResLoading === next.item.isHighResLoading &&
                prev.isLoading === next.isLoading &&
                isBboxSame;

            return isContentSame && prev.isSelected === next.isSelected && prev.isEditing === next.isEditing;
        });

        const PROVIDER_TYPES = [
            { id: 'gemini', name: 'Google Gemini', defaultUrl: 'https://generativelanguage.googleapis.com/v1beta/models/', defaultModel: '' },
            { id: 'openai_official', name: 'OpenAI (Official)', defaultUrl: 'https://api.openai.com/v1/chat/completions', defaultModel: '' },
            { id: 'openai_compat', name: 'OpenAI Compatible (OpenRouter/DeepSeek)', defaultUrl: 'https://openrouter.ai/api/v1/chat/completions', defaultModel: '' },
            { id: 'anthropic', name: 'Anthropic Claude', defaultUrl: 'https://api.anthropic.com/v1/messages', defaultModel: '' }
        ];

        // ë‹¤êµ­ì–´ ì§€ì› ì‹œìŠ¤í…œ
        const TRANSLATIONS = {
            ko: {
                title: 'ANKI MCQ CUTTER',
                aiEngine: 'AI ì—”ì§„',
                profile: 'í”„ë¡œí•„',
                provider: 'Provider',
                model: 'ëª¨ë¸',
                baseUrl: 'Base URL (Optional)',
                apiKeys: 'API Keys',
                addKey: '+ì¶”ê°€',
                save: 'ì €ì¥',
                export1: '1ê°œ ë‚´ë³´ë‚´ê¸°',
                delete: 'ì‚­ì œ',
                newSetting: '+ ìƒˆ ì„¤ì •',
                prompt: 'í”„ë¡¬í”„íŠ¸',
                saveAsNew: 'ìƒˆ ì´ë¦„ ì €ì¥',
                newPrompt: '+ ì‹ ê·œ',
                commonSettings: 'ê³µí†µ ì„¤ì •',
                batchSize: 'Batch Size',
                concurrent: 'ë™ì‹œ ì²˜ë¦¬',
                resultDpi: 'í™”ì§ˆ ì„¤ì • (Result DPI)',
                pdfDpi: 'PDF ë¶„ì„ DPI(ì„œë²„)',
                temperature: 'Temperature',
                dpiRecommend: 'ê¶Œì¥: 100~144',
                tempRange: '0.0 (ì •í™•) ~ 2.0 (ì°½ì˜)',
                padding: 'ì—¬ë°± (Padding)',
                log: 'Log',
                clear: 'Clear',
                pageGallery: 'PAGE GALLERY',
                selectAll: 'ì „ì²´ì„ íƒ',
                deselect: 'í•´ì œ',
                deleteSelected: 'ì„ íƒì‚­ì œ',
                uploadPdf: 'PDF ì—…ë¡œë“œ',
                result: 'RESULT',
                search: 'ë‹¨ì›ëª…, ë²ˆí˜¸ ê²€ìƒ‰...',
                found: 'ê°œ ë°œê²¬',
                reset: 'ì´ˆê¸°í™”',
                fields: 'í•„ë“œ',
                zipDownload: 'ZIP ë‹¤ìš´ë¡œë“œ',
                serverOn: 'Server ON',
                serverOff: 'Server OFF',
                saving: 'ì €ì¥ ì¤‘...',
                saveFailed: 'ì €ì¥ ì‹¤íŒ¨',
                autoSaved: 'ìë™ ì €ì¥ë¨',
                systemProtectOn: 'ì‹œìŠ¤í…œ ë³´í˜¸ (ON)',
                systemProtectOff: 'ì‹œìŠ¤í…œ ë³´í˜¸ (OFF)',
                batchCheck: 'Batch ê²°ê³¼ í™•ì¸',
                batchSend: 'Batch API ì „ì†¡',
                stop: 'ì¤‘ë‹¨',
                continueFrom: 'ì´ì–´ì„œ ì‹œì‘',
                startRealtime: 'ì‹¤ì‹œê°„ ì‹œì‘',
                tips: 'Tips: íƒ­ì„ ë¶„ë¦¬í•´ì„œ ë„ì›Œë‘ë©´ ë©ˆì¶”ì§€ ì•ŠìŠµë‹ˆë‹¤.',
                uploadPdfHere: 'PDFë¥¼ ì—…ë¡œë“œí•˜ì„¸ìš”. (ì„œë²„ ì²˜ë¦¬)',
                converting: 'í˜ì´ì§€ ë³€í™˜ ì¤‘... (ë°±ê·¸ë¼ìš´ë“œ ì‹¤í–‰ ì¤‘)',
                completed: 'ì™„ë£Œë¨',
                rerun: 'ì¬ì‹¤í–‰',
                prev: 'ì´ì „',
                next: 'ë‹¤ìŒ',
                noResults: 'ê²°ê³¼ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤.',
                noSearchResults: 'ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.',
                loading: 'ë¡œë”© ì¤‘...',
                highRes: 'ê³ í™”ì§ˆ ë³€í™˜',
                done: 'ì™„ë£Œ',
                fieldSettings: 'Anki í•„ë“œ ì„¤ì •',
                questionImg: 'ë¬¸ì œ ì´ë¯¸ì§€',
                solutionImg: 'í•´ì„¤ ì´ë¯¸ì§€',
                chapterTag: 'ë‹¨ì›/íƒœê·¸',
                language: 'ì–¸ì–´',
                alias: 'ë³„ì¹­',
                regex: 'ì •ê·œì‹',
                regexSettings: 'ì±•í„° ê·¸ë£¹í™” ì •ê·œì‹',
                regexDesc: 'AIê°€ ì¶”ì¶œí•œ ì±•í„°ëª…ì„ ê·¸ë£¹í™”í•˜ëŠ” ì •ê·œì‹ íŒ¨í„´ì…ë‹ˆë‹¤. ìº¡ì²˜ ê·¸ë£¹ ()ì„ ì‚¬ìš©í•˜ë©´ í•´ë‹¹ ë¶€ë¶„ë§Œ ì¶”ì¶œë©ë‹ˆë‹¤.',
                regexName: 'íŒ¨í„´ ì´ë¦„',
                regexPattern: 'ì •ê·œì‹ íŒ¨í„´',
                addRegex: '+ ì •ê·œì‹ ì¶”ê°€',
                customField: 'ì»¤ìŠ¤í…€ í…ìŠ¤íŠ¸',
                defaultValue: 'ê¸°ë³¸ê°’ (ìƒëµ ê°€ëŠ¥)',
                fieldType: 'í•„ë“œ íƒ€ì…',
                addField: 'í•„ë“œ ì¶”ê°€',
                resetDefault: 'ê¸°ë³¸ê°’ìœ¼ë¡œ ì´ˆê¸°í™”',
                fieldModalTitle: 'Anki í•„ë“œ ì„¤ì •',
                fieldModalDesc: 'ZIP ë‹¤ìš´ë¡œë“œ ì‹œ ìƒì„±ë  Anki í•„ë“œë¥¼ ì„¤ì •í•©ë‹ˆë‹¤. í•„ë“œ ìˆœì„œëŒ€ë¡œ íƒ­ìœ¼ë¡œ êµ¬ë¶„ëœ í…ìŠ¤íŠ¸ê°€ ìƒì„±ë©ë‹ˆë‹¤.',
                newField: 'ìƒˆ í•„ë“œ'
            },
            en: {
                title: 'ANKI MCQ CUTTER',
                aiEngine: 'AI Engine',
                profile: 'Profile',
                provider: 'Provider',
                model: 'Model',
                baseUrl: 'Base URL (Optional)',
                apiKeys: 'API Keys',
                addKey: '+Add',
                save: 'Save',
                export1: 'Export 1',
                delete: 'Delete',
                newSetting: '+ New Setting',
                prompt: 'Prompt',
                saveAsNew: 'Save As New',
                newPrompt: '+ New',
                commonSettings: 'Common Settings',
                batchSize: 'Batch Size',
                concurrent: 'Concurrent',
                resultDpi: 'Result DPI',
                pdfDpi: 'PDF Analysis DPI (Server)',
                temperature: 'Temperature',
                dpiRecommend: 'Recommended: 100~144',
                tempRange: '0.0 (Accurate) ~ 2.0 (Creative)',
                padding: 'Padding',
                log: 'Log',
                clear: 'Clear',
                pageGallery: 'PAGE GALLERY',
                selectAll: 'Select All',
                deselect: 'Deselect',
                deleteSelected: 'Delete Selected',
                uploadPdf: 'Upload PDF',
                result: 'RESULT',
                search: 'Search chapter, number...',
                found: ' found',
                reset: 'Reset',
                fields: 'Fields',
                zipDownload: 'ZIP Download',
                serverOn: 'Server ON',
                serverOff: 'Server OFF',
                saving: 'Saving...',
                saveFailed: 'Save Failed',
                autoSaved: 'Auto Saved',
                systemProtectOn: 'System Protect (ON)',
                systemProtectOff: 'System Protect (OFF)',
                batchCheck: 'Check Batch Result',
                batchSend: 'Send Batch API',
                stop: 'Stop',
                continueFrom: 'Continue From',
                startRealtime: 'Start Realtime',
                tips: 'Tips: Detaching the tab prevents sleeping.',
                uploadPdfHere: 'Upload PDF here. (Server Processing)',
                converting: 'Converting pages... (Background running)',
                completed: 'Completed',
                rerun: 'Rerun',
                prev: 'Prev',
                next: 'Next',
                noResults: 'Results will appear here.',
                noSearchResults: 'No search results.',
                loading: 'Loading...',
                highRes: 'High-Res Converting',
                done: 'Done',
                fieldSettings: 'Anki Field Settings',
                questionImg: 'Question Image',
                solutionImg: 'Solution Image',
                chapterTag: 'Chapter/Tag',
                language: 'Language',
                alias: 'Alias',
                regex: 'Regex',
                regexSettings: 'Chapter Grouping Regex',
                regexDesc: 'Regex patterns to group chapter names extracted by AI. Use capture groups () to extract specific parts.',
                regexName: 'Pattern Name',
                regexPattern: 'Regex Pattern',
                addRegex: '+ Add Regex',
                customField: 'Custom Text',
                defaultValue: 'Default (optional)',
                fieldType: 'Field Type',
                addField: 'Add Field',
                resetDefault: 'Reset to Default',
                fieldModalTitle: 'Anki Field Settings',
                fieldModalDesc: 'Configure Anki fields for ZIP download. Fields are generated as tab-separated text in order.',
                newField: 'New Field'
            },
            zh: {
                title: 'ANKI MCQ CUTTER',
                aiEngine: 'AI å¼•æ“',
                profile: 'é…ç½®æ–‡ä»¶',
                provider: 'æä¾›å•†',
                model: 'æ¨¡å‹',
                baseUrl: 'Base URL (å¯é€‰)',
                apiKeys: 'API å¯†é’¥',
                addKey: '+æ·»åŠ ',
                save: 'ä¿å­˜',
                export1: 'å¯¼å‡º1ä¸ª',
                delete: 'åˆ é™¤',
                newSetting: '+ æ–°è®¾ç½®',
                prompt: 'æç¤ºè¯',
                saveAsNew: 'å¦å­˜ä¸ºæ–°',
                newPrompt: '+ æ–°å»º',
                commonSettings: 'é€šç”¨è®¾ç½®',
                batchSize: 'æ‰¹é‡å¤§å°',
                concurrent: 'å¹¶å‘æ•°',
                resultDpi: 'ç»“æœ DPI',
                pdfDpi: 'PDFåˆ†æDPI(æœåŠ¡å™¨)',
                temperature: 'æ¸©åº¦',
                dpiRecommend: 'æ¨è: 100~144',
                tempRange: '0.0 (ç²¾ç¡®) ~ 2.0 (åˆ›æ„)',
                padding: 'è¾¹è·',
                log: 'æ—¥å¿—',
                clear: 'æ¸…é™¤',
                pageGallery: 'é¡µé¢ç”»å»Š',
                selectAll: 'å…¨é€‰',
                deselect: 'å–æ¶ˆé€‰æ‹©',
                deleteSelected: 'åˆ é™¤é€‰ä¸­',
                uploadPdf: 'ä¸Šä¼ PDF',
                result: 'ç»“æœ',
                search: 'æœç´¢ç« èŠ‚ã€ç¼–å·...',
                found: 'ä¸ªæ‰¾åˆ°',
                reset: 'é‡ç½®',
                fields: 'å­—æ®µ',
                zipDownload: 'ZIP ä¸‹è½½',
                serverOn: 'æœåŠ¡å™¨ å¼€',
                serverOff: 'æœåŠ¡å™¨ å…³',
                saving: 'ä¿å­˜ä¸­...',
                saveFailed: 'ä¿å­˜å¤±è´¥',
                autoSaved: 'è‡ªåŠ¨ä¿å­˜',
                systemProtectOn: 'ç³»ç»Ÿä¿æŠ¤ (å¼€)',
                systemProtectOff: 'ç³»ç»Ÿä¿æŠ¤ (å…³)',
                batchCheck: 'æ£€æŸ¥æ‰¹å¤„ç†ç»“æœ',
                batchSend: 'å‘é€æ‰¹å¤„ç†API',
                stop: 'åœæ­¢',
                continueFrom: 'ç»§ç»­ä»',
                startRealtime: 'å¼€å§‹å®æ—¶',
                tips: 'æç¤º: åˆ†ç¦»æ ‡ç­¾é¡µå¯ä»¥é˜²æ­¢ä¼‘çœ ã€‚',
                uploadPdfHere: 'åœ¨æ­¤ä¸Šä¼ PDFã€‚(æœåŠ¡å™¨å¤„ç†)',
                converting: 'é¡µé¢è½¬æ¢ä¸­... (åå°è¿è¡Œ)',
                completed: 'å·²å®Œæˆ',
                rerun: 'é‡æ–°è¿è¡Œ',
                prev: 'ä¸Šä¸€é¡µ',
                next: 'ä¸‹ä¸€é¡µ',
                noResults: 'ç»“æœå°†åœ¨æ­¤æ˜¾ç¤ºã€‚',
                noSearchResults: 'æ²¡æœ‰æœç´¢ç»“æœã€‚',
                loading: 'åŠ è½½ä¸­...',
                highRes: 'é«˜æ¸…è½¬æ¢',
                done: 'å®Œæˆ',
                fieldSettings: 'Anki å­—æ®µè®¾ç½®',
                questionImg: 'é—®é¢˜å›¾ç‰‡',
                solutionImg: 'è§£ç­”å›¾ç‰‡',
                chapterTag: 'ç« èŠ‚/æ ‡ç­¾',
                language: 'è¯­è¨€',
                alias: 'åˆ«å',
                regex: 'æ­£åˆ™',
                regexSettings: 'ç« èŠ‚åˆ†ç»„æ­£åˆ™',
                regexDesc: 'AIæå–çš„ç« èŠ‚ååˆ†ç»„æ­£åˆ™è¡¨è¾¾å¼ã€‚ä½¿ç”¨æ•è·ç»„()æå–ç‰¹å®šéƒ¨åˆ†ã€‚',
                regexName: 'æ¨¡å¼åç§°',
                regexPattern: 'æ­£åˆ™è¡¨è¾¾å¼',
                addRegex: '+ æ·»åŠ æ­£åˆ™',
                customField: 'è‡ªå®šä¹‰æ–‡æœ¬',
                defaultValue: 'é»˜è®¤å€¼ï¼ˆå¯é€‰ï¼‰',
                fieldType: 'å­—æ®µç±»å‹',
                addField: 'æ·»åŠ å­—æ®µ',
                resetDefault: 'é‡ç½®ä¸ºé»˜è®¤',
                fieldModalTitle: 'Anki å­—æ®µè®¾ç½®',
                fieldModalDesc: 'é…ç½®ZIPä¸‹è½½æ—¶ç”Ÿæˆçš„Ankiå­—æ®µã€‚å­—æ®µæŒ‰é¡ºåºä»¥åˆ¶è¡¨ç¬¦åˆ†éš”ã€‚',
                newField: 'æ–°å­—æ®µ'
            }
        };

        const DEFAULT_PROMPT_CONTENT = `You are an expert AI in exam paper and textbook layout analysis.
Precisely analyze the provided image to identify Multiple Choice Questions (Question) and Solutions (Solution) areas, and return them according to the rules and JSON Schema below.

[Analysis Guidelines]
1. **Question Area Definition**:
   - Identify all areas starting with a question number (e.g., 1, 2, 01, Q1).
   - **Mandatory Inclusions**: You must group the question number, the question text (stem), the choices (options), and **all visual materials (images, charts, graphs, code boxes, etc.)** required to solve the problem into a single 'question' block.
   - Even if the components of a problem are separated (e.g., an image below the text), include them in the same area if they logically belong to one problem.

2. **Solution Area Definition**:
   - Look for areas marked with 'Answer', 'Solution', 'Explanation', 'Guidance', or similar keywords.
   - Define the solution area corresponding 1:1 to a question number as a 'solution' block.
   - Treat areas containing only the correct answer number as 'solution' as well.

3. **Header (Chapter/Tag) Extraction**:
   - Find the chapter name (e.g., "Chapter 1 Introduction", "PART 5", "Section 3") at the top, bottom, or side of the page and extract it as text in the 'header_text' field.
   - If not present, use the nearest parent title or leave it as an empty string.

4. **BBox (Bounding Box) Coordinates**:
   - Return normalized coordinates [ymin, xmin, ymax, xmax] from the top-left (0,0) to the bottom-right (1000,1000) of the image.
   - Capture the area generously so that no text or images are cut off.

[JSON Schema]
{
  "pages": [
    {
      "items": [
        {
          "type": "question" | "solution",
          "number": "Question Number (Numeric string, e.g., '1')",
          "header_text": "Extracted Chapter Name or Title",
          "bbox": [ymin, xmin, ymax, xmax]
        }
      ]
    }
  ]
}`;

        const normalizeApiKeys = (keys) => {
            if (!Array.isArray(keys)) return [{ key: '', name: '' }];
            return keys.map(k => (typeof k === 'string' ? { key: k, name: '' } : k));
        };

        const App = () => {
            const [serverStatus, setServerStatus] = useState(false);
            const [paddings, setPaddings] = useState({ top: 10, bottom: 10, left: 10, right: 10 });
            const [batchSize, setBatchSize] = useState(1);
            const [concurrency, setConcurrency] = useState(3);

            // [NEW] ì»¤ìŠ¤í…€ Anki í•„ë“œ ì„¤ì •
            const DEFAULT_ANKI_FIELDS = [
                { id: 'question_img', name: 'ë¬¸ì œ ì´ë¯¸ì§€', type: 'question', enabled: true, isImage: true },
                { id: 'solution_img', name: 'í•´ì„¤ ì´ë¯¸ì§€', type: 'solution', enabled: true, isImage: true },
                { id: 'chapter', name: 'ë‹¨ì›/íƒœê·¸', type: 'tag', enabled: true, isImage: false }
            ];
            const [ankiFields, setAnkiFields] = useState(() => {
                const saved = localStorage.getItem('anki_fields');
                return saved ? JSON.parse(saved) : DEFAULT_ANKI_FIELDS;
            });
            const [showFieldsModal, setShowFieldsModal] = useState(false);
            const [targetDpi, setTargetDpi] = useState(300);

            // [NEW] ì‚¬ìš©ì ì •ì˜ ì •ê·œì‹ ì„¤ì • (ì±•í„°ëª… ê·¸ë£¹í™”ìš©)
            const DEFAULT_REGEX_PATTERNS = [];
            const [regexPatterns, setRegexPatterns] = useState(() => {
                const saved = localStorage.getItem('regex_patterns');
                return saved ? JSON.parse(saved) : DEFAULT_REGEX_PATTERNS;
            });
            const [showRegexModal, setShowRegexModal] = useState(false);
            useEffect(() => { localStorage.setItem('regex_patterns', JSON.stringify(regexPatterns)); }, [regexPatterns]);

            // ì–¸ì–´ ì„¤ì •
            const [language, setLanguage] = useState(() => {
                const saved = localStorage.getItem('app_language');
                return saved || 'ko';
            });
            const t = TRANSLATIONS[language] || TRANSLATIONS.ko;
            useEffect(() => { localStorage.setItem('app_language', language); }, [language]);

            const [aiProfiles, setAiProfiles] = useState(() => JSON.parse(localStorage.getItem('ai_profiles') || '[]'));
            const [currentAiConfig, setCurrentAiConfig] = useState(() => {
                const saved = localStorage.getItem('last_used_config');
                return saved ? JSON.parse(saved) : {
                    id: 'temp', name: 'í˜„ì¬ ì„¤ì •',
                    providerType: 'gemini', model: 'gemini-2.0-flash-exp',
                    baseUrl: PROVIDER_TYPES[0].defaultUrl,
                    apiKeys: [{ key: '', name: '' }]
                };
            });

            const [promptProfiles, setPromptProfiles] = useState(() => JSON.parse(localStorage.getItem('prompt_profiles') || `[{"id":"default","name":"ê¸°ë³¸ í”„ë¡¬í”„íŠ¸","content":${JSON.stringify(DEFAULT_PROMPT_CONTENT)}}]`));
            const [currentPrompt, setCurrentPrompt] = useState(() => {
                const saved = localStorage.getItem('last_used_prompt');
                return saved ? JSON.parse(saved) : promptProfiles[0];
            });

            // [NEW] Temperature (0.0 - 2.0)
            const [aiTemperature, setAiTemperature] = useState(() => {
                const saved = localStorage.getItem('ai_temperature');
                return saved ? parseFloat(saved) : 0.0;
            });

            // [NEW] PDF DPI (72 - 300)
            const [pdfDpi, setPdfDpi] = useState(() => {
                const saved = localStorage.getItem('pdf_dpi');
                return saved ? parseInt(saved, 10) : 72;
            });

            useEffect(() => { localStorage.setItem('ai_temperature', aiTemperature); }, [aiTemperature]);
            useEffect(() => { localStorage.setItem('pdf_dpi', pdfDpi); }, [pdfDpi]);

            const [pages, setPages] = useState([]);
            const [selectedIds, setSelectedIds] = useState(new Set());
            const [results, setResults] = useState([]);
            const [isRestoring, setIsRestoring] = useState(true);
            const [saveStatus, setSaveStatus] = useState('saved');

            const [resultPage, setResultPage] = useState(0);
            const [tempPageInput, setTempPageInput] = useState("1");
            const [searchTerm, setSearchTerm] = useState("");

            const filteredResults = useMemo(() => {
                if (!searchTerm.trim()) return results;
                const lower = searchTerm.toLowerCase();
                return results.map(page => {
                    const matchingItems = page.items.filter(it =>
                        (it.chapter && it.chapter.toLowerCase().includes(lower)) ||
                        (it.number && String(it.number).includes(lower))
                    );
                    if (matchingItems.length > 0) return { ...page, items: matchingItems };
                    return null;
                }).filter(Boolean);
            }, [results, searchTerm]);

            useEffect(() => setResultPage(0), [searchTerm]);
            useEffect(() => { setTempPageInput(String(resultPage + 1)); }, [resultPage]);
            const applyPageInput = () => {
                const val = parseInt(tempPageInput, 10);
                if (!isNaN(val) && val >= 1 && val <= Math.ceil(filteredResults.length / ITEMS_PER_PAGE)) {
                    setResultPage(val - 1);
                } else {
                    setTempPageInput(String(resultPage + 1));
                }
            };
            const ITEMS_PER_PAGE = 5;
            const resultLoaderRef = useRef(null);
            const [selectedResultIds, setSelectedResultIds] = useState(new Set());

            const userEditsRef = useRef(JSON.parse(localStorage.getItem('user_edits') || '{}'));
            const deletedItemsRef = useRef(new Set(JSON.parse(localStorage.getItem('deleted_items') || '[]')));

            const [logs, setLogs] = useState([]);
            const [isProcessing, setIsProcessing] = useState(false);
            const [isLoadingPdf, setIsLoadingPdf] = useState(false);
            const [previewImg, setPreviewImg] = useState(null);
            const [isZoomed, setIsZoomed] = useState(false);
            const [retryingPage, setRetryingPage] = useState(null);

            const [editingItem, setEditingItem] = useState(null);
            const [loadingEditId, setLoadingEditId] = useState(null);

            const editBboxRef = useRef(null);
            const editingImageObjRef = useRef(null);

            const [batchId, setBatchId] = useState(localStorage.getItem('last_batch_id') || null);
            const [scrollTop, setScrollTop] = useState(0);
            const [containerWidth, setContainerWidth] = useState(0);
            const [guardActive, setGuardActive] = useState(false);

            const [pdfJobId, setPdfJobId] = useState(localStorage.getItem('last_pdf_job_id'));
            const [pdfProcessedCount, setPdfProcessedCount] = useState(0);

            const galleryContainerRef = useRef(null);
            const lastKeyIdxRef = useRef(0);
            const stopRef = useRef(false);
            const abortControllerRef = useRef(null);
            const aiFileRef = useRef(null);
            const promptFileRef = useRef(null);

            const workerRef = useRef(null);
            const audioCtxRef = useRef(null);
            const scriptNodeRef = useRef(null);
            const wakeLockRef = useRef(null);
            const [pingCount, setPingCount] = useState(0);
            const [tempPdfCount, setTempPdfCount] = useState(0);

            const processedPageNums = useMemo(() => new Set(results.map(r => r.pageNum)), [results]);

            const log = (msg) => setLogs(prev => [...prev.slice(-50), `${new Date().toLocaleTimeString()}: ${msg}`]);

            useEffect(() => {
                const restoreData = async () => {
                    try {
                        const legacyData = localStorage.getItem('auto_saved_results');
                        if (legacyData) {
                            const parsed = JSON.parse(legacyData);
                            if (parsed.length > 0) {
                                await idbSave('results', parsed);
                                localStorage.removeItem('auto_saved_results');
                            }
                        }
                        const savedResults = await idbLoad('results');
                        if (savedResults && Array.isArray(savedResults)) {
                            setResults(savedResults);
                            log(`ğŸ“‚ ì§€ë‚œ ì‘ì—… ë³µêµ¬ ì™„ë£Œ (${savedResults.length} í˜ì´ì§€)`);
                        }
                        const savedEdits = await idbLoad('user_edits');
                        if (savedEdits) userEditsRef.current = savedEdits;
                        const savedDeleted = await idbLoad('deleted_items');
                        if (savedDeleted) deletedItemsRef.current = new Set(savedDeleted);
                    } catch (e) { console.error("Restore failed:", e); }
                    finally { setIsRestoring(false); }
                };
                restoreData();
            }, []);

            useEffect(() => {
                if (isRestoring) return;
                const save = async () => {
                    setSaveStatus('saving');
                    try { await idbSave('results', results); setSaveStatus('saved'); }
                    catch (e) { console.error("Save failed", e); setSaveStatus('error'); }
                };
                const timeout = setTimeout(save, 30000);
                return () => clearTimeout(timeout);
            }, [results]);

            const saveEdits = async () => {
                await idbSave('user_edits', userEditsRef.current);
                await idbSave('deleted_items', [...deletedItemsRef.current]);
            };

            useEffect(() => {
                if (!resultLoaderRef.current) return;
            }, [resultPage]);

            useEffect(() => {
                const checkServer = async () => {
                    try {
                        const res = await fetch('http://localhost:8000/');
                        if (res.ok) {
                            setServerStatus(true);
                            // temp_pdfs ê°œìˆ˜ë„ í•¨ê»˜ ì²´í¬
                            const countRes = await fetch('http://localhost:8000/temp_pdf_count');
                            if (countRes.ok) {
                                const data = await countRes.json();
                                setTempPdfCount(data.count || 0);
                            }
                        }
                        else setServerStatus(false);
                    } catch (e) { setServerStatus(false); }
                };
                checkServer();
                const interval = setInterval(checkServer, 5000);
                return () => clearInterval(interval);
            }, []);

            useEffect(() => { localStorage.setItem('ai_profiles', JSON.stringify(aiProfiles)); }, [aiProfiles]);
            useEffect(() => { localStorage.setItem('prompt_profiles', JSON.stringify(promptProfiles)); }, [promptProfiles]);
            useEffect(() => { localStorage.setItem('last_used_config', JSON.stringify(currentAiConfig)); }, [currentAiConfig]);
            useEffect(() => { localStorage.setItem('last_used_prompt', JSON.stringify(currentPrompt)); }, [currentPrompt]);
            useEffect(() => { localStorage.setItem('anki_fields', JSON.stringify(ankiFields)); }, [ankiFields]);

            useEffect(() => {
                const initAudioSystem = () => {
                    if (!audioCtxRef.current) {
                        const AudioContext = window.AudioContext || window.webkitAudioContext;
                        if (AudioContext) {
                            audioCtxRef.current = new AudioContext();
                        }
                    }
                    if (audioCtxRef.current && audioCtxRef.current.state === 'suspended') {
                        audioCtxRef.current.resume().catch(() => { });
                    }
                };
                window.addEventListener('click', initAudioSystem, { once: true });
                window.addEventListener('touchstart', initAudioSystem, { once: true });
                return () => {
                    window.removeEventListener('click', initAudioSystem);
                    window.removeEventListener('touchstart', initAudioSystem);
                };
            }, []);

            useEffect(() => {
                const handleError = (e) => {
                    if (e.message && e.message.includes('ResizeObserver')) {
                        e.stopImmediatePropagation();
                    }
                };
                window.addEventListener('error', handleError);
                return () => window.removeEventListener('error', handleError);
            }, []);

            useEffect(() => {
                const handleEsc = (e) => { if (e.key === 'Escape') { setPreviewImg(null); setIsZoomed(false); setEditingItem(null); } };
                window.addEventListener('keydown', handleEsc);
                let obs = null;
                if (galleryContainerRef.current) {
                    obs = new ResizeObserver(entries => { if (entries[0]) setContainerWidth(entries[0].contentRect.width); });
                    obs.observe(galleryContainerRef.current);
                }
                return () => { window.removeEventListener('keydown', handleEsc); if (obs) obs.disconnect(); };
            }, [galleryContainerRef.current]);

            const toggleGuard = (forceOn = false) => {
                const shouldActivate = forceOn || !guardActive;
                if (!shouldActivate) {
                    if (scriptNodeRef.current) { try { scriptNodeRef.current.disconnect(); } catch (e) { } scriptNodeRef.current = null; }
                    if (workerRef.current) { workerRef.current.terminate(); workerRef.current = null; }
                    if (wakeLockRef.current) { wakeLockRef.current.release().catch(() => { }); wakeLockRef.current = null; }
                    setGuardActive(false); log("ğŸ”• ì‹œìŠ¤í…œ ë³´í˜¸ í•´ì œ");
                } else {
                    setGuardActive(true); log("ğŸ›¡ï¸ ì‹œìŠ¤í…œ ë³´í˜¸ ê°€ë™ (Worker Metronome Mode)");
                    if (audioCtxRef.current) {
                        if (audioCtxRef.current.state === 'suspended') audioCtxRef.current.resume();
                        if (!scriptNodeRef.current) {
                            try {
                                const processor = audioCtxRef.current.createScriptProcessor(4096, 1, 1);
                                processor.onaudioprocess = (e) => { const output = e.outputBuffer.getChannelData(0); for (let i = 0; i < output.length; i++) { output[i] = (Math.random() * 0.002) - 0.001; } };
                                processor.connect(audioCtxRef.current.destination); scriptNodeRef.current = processor;
                            } catch (e) { console.warn("Audio fail", e); }
                        }
                    }
                    try {
                        if (!workerRef.current) {
                            const blob = new Blob([`self.onmessage = function(e) { if (e.data === 'start') { setInterval(function() { self.postMessage('tick'); }, 250); } };`], { type: "application/javascript" });
                            workerRef.current = new Worker(URL.createObjectURL(blob));
                            workerRef.current.onmessage = (e) => { if (e.data === 'tick') { setPingCount(c => (c + 1) % 100); } };
                            workerRef.current.postMessage('start');
                        }
                    } catch (e) { console.error("Worker fail", e); }
                    if ('wakeLock' in navigator) navigator.wakeLock.request('screen').then(l => wakeLockRef.current = l).catch(() => { });
                }
            };

            const gridConfig = useMemo(() => {
                const safeWidth = containerWidth === 0 ? 1200 : containerWidth;
                let cols = 3;
                if (safeWidth >= 640) cols = 4; if (safeWidth >= 768) cols = 5; if (safeWidth >= 1280) cols = 6;
                const gap = 16; const padding = 32;
                const itemWidth = Math.max(10, (safeWidth - padding - (gap * (cols - 1))) / cols);
                const itemHeight = itemWidth * (4 / 3);
                return { cols, gap, itemHeight };
            }, [containerWidth]);

            const virtualItems = useMemo(() => {
                if (!pages.length) return { items: [], totalHeight: 0 };
                const { cols, gap, itemHeight } = gridConfig;
                const totalRows = Math.ceil(pages.length / cols);
                const totalHeight = totalRows * itemHeight + (totalRows - 1) * gap;
                const buffer = 2; const startRow = Math.max(0, Math.floor(scrollTop / (itemHeight + gap)) - buffer); const endRow = Math.min(totalRows, Math.ceil((scrollTop + 500) / (itemHeight + gap)) + buffer);
                const visibleItems = [];
                for (let r = startRow; r < endRow; r++) {
                    for (let c = 0; c < cols; c++) {
                        const idx = r * cols + c;
                        if (idx < pages.length) {
                            visibleItems.push({ ...pages[idx], originalIndex: idx, style: { position: 'absolute', top: r * (itemHeight + gap), left: c * ((containerWidth - 32 - (gap * (cols - 1))) / cols + gap) + 16, width: (containerWidth - 32 - (gap * (cols - 1))) / cols, height: itemHeight } });
                        }
                    }
                }
                return { items: visibleItems, totalHeight };
            }, [pages, scrollTop, gridConfig, containerWidth]);

            const loadAiProfile = (e) => { const id = e.target.value; if (id === 'new') { setCurrentAiConfig({ id: 'temp', name: '', providerType: 'gemini', model: '', baseUrl: '', apiKeys: [{ key: '', name: '' }] }); } else { const found = aiProfiles.find(p => p.id === id); if (found) setCurrentAiConfig({ ...found, apiKeys: normalizeApiKeys(found.apiKeys || (found.apiKey ? [found.apiKey] : [])) }); } };
            const saveAiProfile = () => { const name = prompt("í”„ë¡œí•„ ì´ë¦„:", currentAiConfig.name); if (name) setAiProfiles(prev => [...prev.filter(p => p.id !== currentAiConfig.id), { ...currentAiConfig, id: `ai_${Date.now()}`, name }]); };
            const deleteAiProfile = () => { if (confirm("ì‚­ì œ?")) setAiProfiles(prev => prev.filter(p => p.id !== currentAiConfig.id)); };
            const exportAiProfiles = () => { const b = new Blob([JSON.stringify(aiProfiles, null, 2)], { type: "application/json" }); const a = document.createElement('a'); a.href = URL.createObjectURL(b); a.download = "Profiles.json"; a.click(); };
            const exportCurrentAiProfile = () => { if (currentAiConfig.id === 'temp') return alert('ì €ì¥ í›„ ë‚´ë³´ë‚´ì„¸ìš”'); const b = new Blob([JSON.stringify([currentAiConfig], null, 2)], { type: "application/json" }); const a = document.createElement('a'); a.href = URL.createObjectURL(b); a.download = `Profile_${currentAiConfig.name}.json`; a.click(); };
            const importAiProfiles = (e) => { const r = new FileReader(); r.onload = v => { try { const imported = JSON.parse(v.target.result); setAiProfiles(prev => { const merged = [...prev]; imported.forEach(p => { const idx = merged.findIndex(m => m.id === p.id); if (idx >= 0) merged[idx] = p; else merged.push(p); }); return merged; }); alert(`${imported.length}ê°œ í”„ë¡œí•„ ì¶”ê°€ë¨`); } catch (x) { alert('ì˜¤ë¥˜'); } }; if (e.target.files[0]) r.readAsText(e.target.files[0]); e.target.value = ''; };
            const updateKey = (i, f, v) => { const k = [...currentAiConfig.apiKeys]; k[i] = { ...k[i], [f]: v }; setCurrentAiConfig({ ...currentAiConfig, apiKeys: k }); };
            const addKey = () => setCurrentAiConfig({ ...currentAiConfig, apiKeys: [...currentAiConfig.apiKeys, { key: '', name: '' }] });
            const removeKey = (i) => setCurrentAiConfig({ ...currentAiConfig, apiKeys: currentAiConfig.apiKeys.filter((_, x) => x !== i) });
            const createNewPrompt = () => setCurrentPrompt({ id: `temp_${Date.now()}`, name: 'ìƒˆ í”„ë¡¬í”„íŠ¸', content: DEFAULT_PROMPT_CONTENT });
            const updateCurrentPrompt = () => { const exists = promptProfiles.find(p => p.id === currentPrompt.id); if (exists) { setPromptProfiles(prev => prev.map(p => p.id === currentPrompt.id ? currentPrompt : p)); alert('ì™„ë£Œ'); } else savePromptAsNew(); };
            const savePromptAsNew = () => { const name = prompt("ì´ë¦„:", currentPrompt.name); if (name) { const n = { ...currentPrompt, id: `pmt_${Date.now()}`, name }; setPromptProfiles(prev => [...prev, n]); setCurrentPrompt(n); } };
            const deletePromptProfile = () => { if (promptProfiles.length <= 1) return; if (confirm('ì‚­ì œ?')) { const n = promptProfiles.filter(p => p.id !== currentPrompt.id); setPromptProfiles(n); setCurrentPrompt(n[0]); } };
            const exportPrompts = () => { const b = new Blob([JSON.stringify(promptProfiles, null, 2)], { type: "application/json" }); const a = document.createElement('a'); a.href = URL.createObjectURL(b); a.download = "Prompts.json"; a.click(); };
            const exportCurrentPrompt = () => { const b = new Blob([JSON.stringify([currentPrompt], null, 2)], { type: "application/json" }); const a = document.createElement('a'); a.href = URL.createObjectURL(b); a.download = `Prompt_${currentPrompt.name}.json`; a.click(); };
            const importPrompts = (e) => { const r = new FileReader(); r.onload = v => { try { const imported = JSON.parse(v.target.result); setPromptProfiles(prev => { const merged = [...prev]; imported.forEach(p => { const idx = merged.findIndex(m => m.id === p.id); if (idx >= 0) merged[idx] = p; else merged.push(p); }); return merged; }); alert(`${imported.length}ê°œ í”„ë¡¬í”„íŠ¸ ì¶”ê°€ë¨`); } catch (x) { alert('ì˜¤ë¥˜'); } }; if (e.target.files[0]) r.readAsText(e.target.files[0]); e.target.value = ''; };

            const handlePdf = async (e) => {
                const files = Array.from(e.target.files);
                if (!files.length) return;
                if (!serverStatus) return alert("ì„œë²„ ì—°ê²°ì´ í•„ìš”í•©ë‹ˆë‹¤. (server.py ì‹¤í–‰ í™•ì¸)");
                // ì‹œìŠ¤í…œ ë³´í˜¸ ìë™ í™œì„±í™” ì œê±° (ìˆ˜ë™ ì œì–´ë¡œ ë³€ê²½)

                setIsLoadingPdf(true);
                setPages([]);

                if (results.length > 0) {
                    if (confirm("ê¸°ì¡´ ê²°ê³¼ë¥¼ ì´ˆê¸°í™”í•˜ê³  ìƒˆë¡œ ì‹œì‘í•˜ì‹œê² ìŠµë‹ˆê¹Œ? (ì·¨ì†Œ ì‹œ ê¸°ì¡´ ê²°ê³¼ ìœ ì§€)")) {
                        setResults([]);
                        userEditsRef.current = {};
                        deletedItemsRef.current = new Set();
                        await idbSave('results', []);
                        await idbSave('user_edits', {});
                        await idbSave('deleted_items', []);
                    }
                }

                const file = files[0];
                const formData = new FormData();
                formData.append("file", file);
                formData.append("dpi", pdfDpi); // [NEW] DPI ì „ì†¡

                try {
                    log(`ğŸ“¤ ${file.name} ì„œë²„ë¡œ ì—…ë¡œë“œ ì¤‘...`);
                    const res = await fetch("http://localhost:8000/upload_pdf", { method: "POST", body: formData });
                    if (!res.ok) throw new Error("ì—…ë¡œë“œ ì‹¤íŒ¨");
                    const data = await res.json();
                    setPdfJobId(data.job_id);

                    localStorage.setItem('last_pdf_job_id', data.job_id);

                    setPdfProcessedCount(0);
                    log("âœ… ì—…ë¡œë“œ ì™„ë£Œ! ì„œë²„ì—ì„œ ë³€í™˜ ì¤‘ì…ë‹ˆë‹¤.");
                } catch (err) {
                    log(`âŒ ì—…ë¡œë“œ ì—ëŸ¬: ${err.message}`);
                    setIsLoadingPdf(false);
                }
            };

            useEffect(() => {
                let interval = null;
                if (pdfJobId && isLoadingPdf) {
                    interval = setInterval(async () => {
                        try {
                            const res = await fetch(`http://localhost:8000/check_pdf_job/${pdfJobId}?last_index=${pdfProcessedCount}`);
                            if (!res.ok) return;
                            const data = await res.json();

                            if (data.new_pages && data.new_pages.length > 0) {
                                setPages(prev => {
                                    const existingIds = new Set(prev.map(p => p.id));
                                    const uniqueNewPages = data.new_pages.filter(p => !existingIds.has(p.id));
                                    if (uniqueNewPages.length === 0) return prev;
                                    return [...prev, ...uniqueNewPages];
                                });
                                setPdfProcessedCount(data.next_index);
                                document.title = `PDF ${data.processed_count}/${data.total_pages}`;
                            }

                            if (data.status === "done") {
                                setIsLoadingPdf(false);
                                log("ğŸ‰ ëª¨ë“  í˜ì´ì§€ ë¡œë“œ ì™„ë£Œ!");
                                document.title = "Anki Turbo PRO";
                            } else if (data.status === "failed") {
                                setPdfJobId(null);
                                setIsLoadingPdf(false);
                                alert(`ë³€í™˜ ì‹¤íŒ¨: ${data.error}`);
                            }
                        } catch (e) { console.error("Polling error", e); }
                    }, 1000);
                }
                return () => { if (interval) clearInterval(interval); };
            }, [pdfJobId, pdfProcessedCount, isLoadingPdf]);

            // [ì •ë¦¬ë¨] AI í˜¸ì¶œ í•¨ìˆ˜: ì„œë²„ë¥¼ í†µí•´ì„œë§Œ ìš”ì²­ (ì¤‘ë³µ ì½”ë“œ ì œê±°)
            const callLLM = async (config, apiKeyData, prompt, images, signal) => {
                console.log(`ğŸ“¡ AI ìš”ì²­ ì‹œì‘: ${config.model} (ì´ë¯¸ì§€ ${images.length}ì¥)`);

                try {
                    if (signal.aborted || stopRef.current) return null;

                    if (!serverStatus) {
                        throw new Error("ì„œë²„ê°€ ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. server.pyë¥¼ ì‹¤í–‰í•´ì£¼ì„¸ìš”.");
                    }

                    const host = "127.0.0.1:8000";
                    const url = `http://${host}/process_single`;

                    const response = await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            api_key: apiKeyData.key,
                            model: config.model,
                            prompt: prompt,
                            images: images,
                            provider: config.providerType.startsWith('openai') ? 'openai' : config.providerType,
                            base_url: config.baseUrl,
                            temperature: aiTemperature // [NEW] Temperature ì „ì†¡
                        }),
                        signal
                    });

                    if (!response.ok) {
                        const errText = await response.text();
                        console.error(`ì„œë²„ ì‘ë‹µ ì—ëŸ¬: ${errText}`);
                        throw new Error(`Server Error: ${errText}`);
                    }

                    const jsonRes = await response.json();
                    console.log("âœ… AI ì‘ë‹µ ìˆ˜ì‹  ì™„ë£Œ");
                    return jsonRes;

                } catch (e) {
                    console.error("CallLLM Exception:", e);
                    throw e;
                }
            };

            // [FIXED] ê°€ìœ„ì§ˆ í•¨ìˆ˜: ë³´ì´ëŠ” ê·¸ëŒ€ë¡œ ì •í™•í•˜ê²Œ ìë¥´ë„ë¡ ìˆ˜í•™ì  ì •ë°€ë„ ê°œì„ 
            const cutImageFromBase = (imgSource, bbox) => {
                const [y1, x1, y2, x2] = bbox;
                const cvs = document.createElement('canvas');
                const ctx = cvs.getContext('2d');

                const imgObj = (typeof imgSource === 'string') ? new Image() : imgSource;

                const draw = () => {
                    const baseW = imgObj.naturalWidth || imgObj.width;
                    const baseH = imgObj.naturalHeight || imgObj.height;

                    // 1000ë¶„ìœ¨ ì¢Œí‘œë¥¼ í”½ì…€ë¡œ ë³€í™˜ (ë°˜ì˜¬ë¦¼í•˜ì—¬ í”½ì…€ ê²½ê³„ ë§ì¶¤)
                    let sX = Math.round((x1 / 1000) * baseW);
                    let sY = Math.round((y1 / 1000) * baseH);
                    let eX = Math.round((x2 / 1000) * baseW);
                    let eY = Math.round((y2 / 1000) * baseH);

                    // ë²”ìœ„ ì•ˆì „ì¥ì¹˜
                    sX = Math.max(0, sX); sY = Math.max(0, sY);
                    eX = Math.min(baseW, eX); eY = Math.min(baseH, eY);

                    cvs.width = eX - sX;
                    cvs.height = eY - sY;

                    if (cvs.width > 0 && cvs.height > 0) {
                        ctx.drawImage(imgObj, sX, sY, cvs.width, cvs.height, 0, 0, cvs.width, cvs.height);
                        return cvs.toDataURL('image/webp', 0.9); // í™”ì§ˆ ì•½ê°„ ë†’ì„
                    }
                    return null;
                };

                if (typeof imgSource === 'string') {
                    return new Promise(resolve => {
                        imgObj.onload = () => resolve(draw());
                        imgObj.src = imgSource;
                    });
                } else {
                    return draw();
                }
            };

            // [FIXED] ë°°ì¹˜ ì²˜ë¦¬ ì§€ì›: ì—¬ëŸ¬ í˜ì´ì§€ë¥¼ í•œ ë²ˆì— ì²˜ë¦¬
            const processBatchWorker = async (pageItems, config, apiKeyData, promptText, signal) => {
                try {
                    if (stopRef.current || signal.aborted) return null;

                    // pageItemsê°€ ë°°ì—´ì´ ì•„ë‹ˆë©´ ë°°ì—´ë¡œ ë³€í™˜ (ë‹¨ì¼ í˜ì´ì§€ í˜¸í™˜)
                    const pagesArray = Array.isArray(pageItems) ? pageItems : [pageItems];
                    const highResImgs = [];
                    const pageNums = [];

                    // ê° í˜ì´ì§€ì—ì„œ ì´ë¯¸ì§€ ì¶”ì¶œ
                    for (const pageItem of pagesArray) {
                        pageNums.push(pageItem.pageNum);
                        if (pageItem.is_server_processed && pageItem.thumb) {
                            highResImgs.push(pageItem.thumb);
                        } else if (pageItem.pdfDoc) {
                            const dpiScale = Math.max(0.5, targetDpi / 72);
                            const pg = await pageItem.pdfDoc.getPage(pageItem.pageNum);
                            const vp = pg.getViewport({ scale: dpiScale });
                            const cvs = document.createElement('canvas');
                            cvs.height = vp.height; cvs.width = vp.width;
                            await pg.render({ canvasContext: cvs.getContext('2d'), viewport: vp }).promise;
                            highResImgs.push(cvs.toDataURL('image/jpeg', 0.85));
                        } else {
                            console.warn(`ì´ë¯¸ì§€ ì†ŒìŠ¤ ì—†ìŒ: p.${pageItem.pageNum}`);
                            throw new Error("Image Source Not Found");
                        }
                    }

                    // AI í˜¸ì¶œ (ì—¬ëŸ¬ ì´ë¯¸ì§€ í•œ ë²ˆì— ì „ì†¡)
                    const data = await callLLM(config, apiKeyData, promptText, highResImgs, signal);
                    if (stopRef.current || !data || !data.pages) return null;

                    // ê²°ê³¼ ì²˜ë¦¬: ê° í˜ì´ì§€ë³„ë¡œ ë¶„ë¦¬í•˜ì—¬ ë°˜í™˜
                    const allResults = [];
                    const currentJobId = pdfJobId || localStorage.getItem("last_pdf_job_id");

                    for (let pageIdx = 0; pageIdx < pagesArray.length; pageIdx++) {
                        const pageItem = pagesArray[pageIdx];
                        const pageData = data.pages[pageIdx];
                        if (!pageData || !pageData.items || pageData.items.length === 0) continue;

                        const rawItems = pageData.items;

                        if (!currentJobId) {
                            // Job ID ì—†ìœ¼ë©´ ì›ë³¸ ì¢Œí‘œë§Œ ë°˜í™˜
                            allResults.push({
                                pageNum: pageItem.pageNum,
                                items: rawItems.map((it, idx) => ({
                                    ...it, img: pageItem.thumb, fName: `ITEM_${Date.now()}_${pageIdx}_${idx}.webp`
                                }))
                            });
                            continue;
                        }

                        // ì„œë²„ë¡œ ìë¥´ê¸° ìš”ì²­
                        const cropPayload = {
                            job_id: currentJobId,
                            page_num: pageItem.pageNum,
                            items: rawItems.map((it, idx) => {
                                const [y1, x1, y2, x2] = it.bbox || [0, 0, 0, 0];
                                const newBbox = [
                                    Math.max(0, y1 - paddings.top),
                                    Math.max(0, x1 - paddings.left),
                                    Math.min(1000, y2 + paddings.bottom),
                                    Math.min(1000, x2 + paddings.right)
                                ];
                                it.bbox = newBbox;
                                return { id: `temp_${idx}`, bbox: newBbox };
                            }),
                            dpi: targetDpi
                        };

                        try {
                            const cropRes = await fetch("http://127.0.0.1:8000/crop_batch_items", {
                                method: "POST", headers: { "Content-Type": "application/json" },
                                body: JSON.stringify(cropPayload)
                            });

                            if (!cropRes.ok) throw new Error("Server Crop Failed");
                            const cropData = await cropRes.json();

                            const validItems = [];
                            for (let i = 0; i < rawItems.length; i++) {
                                const raw = rawItems[i];
                                const serverImg = cropData.results[i];
                                if (raw.type !== 'ignore') {
                                    const finalImg = (serverImg && serverImg.img) ? serverImg.img : pageItem.thumb;
                                    validItems.push({
                                        ...raw,
                                        img: finalImg,
                                        raw_number: raw.number,
                                        raw_chapter: raw.header_text,
                                        fName: `ITEM_${Date.now()}_${pageIdx}_${i}.webp`
                                    });
                                }
                            }
                            if (validItems.length) allResults.push({ pageNum: pageItem.pageNum, items: validItems });
                        } catch (cropErr) {
                            console.error("Crop error for page", pageItem.pageNum, cropErr);
                            // ìë¥´ê¸° ì‹¤íŒ¨í•´ë„ ê²°ê³¼ëŠ” ì‚´ë¦¼
                            allResults.push({
                                pageNum: pageItem.pageNum,
                                items: rawItems.filter(it => it.type !== 'ignore').map((it, idx) => ({
                                    ...it, img: pageItem.thumb, raw_number: it.number, raw_chapter: it.header_text,
                                    fName: `ITEM_${Date.now()}_${pageIdx}_${idx}.webp`
                                }))
                            });
                        }
                    }

                    return allResults.length > 0 ? allResults : null;

                } catch (e) {
                    if (e.message && (e.message.includes("429") || e.message.includes("Quota") || e.message.includes("Too Many Requests"))) return 'RATE_LIMIT';
                    console.error("Worker Error:", e);
                    return null;
                }
            };

            const recalculateContext = (rawList) => {
                if (!Array.isArray(rawList)) return [];
                const sortedRaw = [...rawList].sort((a, b) => a.pageNum - b.pageNum);
                let currentChapter = "Unknown_Chapter", currentQNum = "unknown";
                return sortedRaw.map(pageRes => {
                    if (!pageRes || !pageRes.items) return { ...pageRes, items: [] };
                    const activeItems = pageRes.items.filter((_, itemIdx) => {
                        const key = `${pageRes.pageNum}-${itemIdx}`;
                        return !deletedItemsRef.current.has(key);
                    });
                    const newItems = activeItems.map((it) => {
                        if (!it) return null;
                        const originalIndex = pageRes.items.indexOf(it);
                        if (it.raw_chapter && it.raw_chapter.length > 1) {
                            // [ê°œì„ ë¨] 'í¸/ì¥/ê°•' ëª¨ë‘ ì§€ì› ë° í¬ë§· í†µì¼ ('ì œ_1_í¸' -> 'ì œ1í¸ ')
                            currentChapter = it.raw_chapter.trim()
                                .replace(/^ì œ[\s_]*(\d+)[\s_]*([í¸ì¥ê°•])[\s_]*/, 'ì œ$1$2 ')
                                .trim().substring(0, 50);
                        }
                        let finalNum = it.raw_number;
                        if (it.type === 'question' || (it.type === 'solution' && it.raw_number)) { if (it.raw_number) { currentQNum = it.raw_number; finalNum = it.raw_number; } }
                        else if (it.type === 'solution_cont' || !it.raw_number || it.raw_number === 'cont') { finalNum = currentQNum; }

                        const editKey = `${pageRes.pageNum}-${originalIndex}`;
                        const userEdit = userEditsRef.current[editKey];
                        let finalBbox = it.bbox; let finalImg = it.img;
                        if (userEdit) { finalBbox = userEdit.bbox; finalImg = userEdit.img; }

                        const itemId = it.fName || `item_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

                        return {
                            ...it, bbox: finalBbox, img: finalImg, number: finalNum, chapter: currentChapter,
                            fName: itemId,
                            originalItemIndex: originalIndex
                        };
                    }).filter(Boolean);
                    return { ...pageRes, items: newItems };
                });
            };

            // [ê°œì„ ë¨] í¸ì§‘ ì‹œì‘ - ì„œë²„ ìš”ì²­ ì‹¤íŒ¨ ì‹œ ê¸°ì¡´ ì´ë¯¸ì§€ë¥¼ fallbackìœ¼ë¡œ ì‚¬ìš©
            const startEditing = async (pageNum, itemIdx, currentBbox) => {
                const uniqueKey = `${pageNum}-${itemIdx}`;
                setLoadingEditId(uniqueKey);

                try {
                    let sourceImgUrl = "";

                    // 1ìˆœìœ„: ë©”ëª¨ë¦¬ì— ìˆëŠ” í˜ì´ì§€ ì¸ë„¤ì¼
                    const pageInMem = pages.find(p => p.pageNum === pageNum);
                    if (pageInMem && pageInMem.thumb) {
                        sourceImgUrl = pageInMem.thumb;
                    } else {
                        // 2ìˆœìœ„: ì„œë²„ì—ì„œ í˜ì´ì§€ ì´ë¯¸ì§€ ìš”ì²­
                        const currentJobId = pdfJobId || localStorage.getItem('last_pdf_job_id');
                        if (currentJobId) {
                            try {
                                const res = await fetch("http://127.0.0.1:8000/get_page_image", {
                                    method: "POST", headers: { "Content-Type": "application/json" },
                                    body: JSON.stringify({ job_id: currentJobId, page_num: pageNum, dpi: 100 })
                                });
                                if (res.ok) {
                                    const data = await res.json();
                                    sourceImgUrl = data.img;
                                }
                            } catch (e) {
                                console.warn("ì„œë²„ ì´ë¯¸ì§€ ìš”ì²­ ì‹¤íŒ¨, fallback ì‚¬ìš©", e);
                            }
                        }
                    }

                    // 3ìˆœìœ„: ê²°ê³¼ ì•„ì´í…œì˜ ê¸°ì¡´ ì´ë¯¸ì§€ (fallback)
                    if (!sourceImgUrl) {
                        const pageResult = results.find(r => r.pageNum === pageNum);
                        const item = pageResult?.items.find(it => it.originalItemIndex === itemIdx);
                        if (item && item.img) {
                            // ì•„ì´í…œ ì´ë¯¸ì§€ ìì²´ë¥¼ ì†ŒìŠ¤ë¡œ ì‚¬ìš© (ì œí•œì ì´ì§€ë§Œ í¸ì§‘ ê°€ëŠ¥)
                            sourceImgUrl = item.img;
                            console.log("Fallback: ì•„ì´í…œ ì´ë¯¸ì§€ë¥¼ ì†ŒìŠ¤ë¡œ ì‚¬ìš©");
                        }
                    }

                    if (!sourceImgUrl) {
                        throw new Error("ì´ë¯¸ì§€ ì†ŒìŠ¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. PDFë¥¼ ë‹¤ì‹œ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”.");
                    }

                    const highResImg = new Image();
                    highResImg.src = sourceImgUrl;
                    await highResImg.decode();

                    editingImageObjRef.current = highResImg;
                    editBboxRef.current = [...currentBbox];

                    const highQualityCut = await cutImageFromBase(highResImg, currentBbox);

                    setEditingItem({
                        pageNum,
                        itemIdx,
                        baseImg: sourceImgUrl,
                        tempImg: highQualityCut,
                        bbox: [...currentBbox],
                        isEditLoading: false
                    });

                } catch (e) {
                    console.warn("í¸ì§‘ ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨", e);
                    alert(e.message || "ì´ë¯¸ì§€ ë¡œë“œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
                } finally {
                    setLoadingEditId(null);
                }
            };

            const updateEditBbox = useCallback(async (direction, amount) => {
                if (!editingItem || !editBboxRef.current) return;

                const newBbox = [...editBboxRef.current];
                const step = amount === 10 ? 5 : amount;

                if (direction === 'top') newBbox[0] = Math.max(0, newBbox[0] - step);
                if (direction === 'bottom') newBbox[2] = Math.min(1000, newBbox[2] + step);
                if (direction === 'left') newBbox[1] = Math.max(0, newBbox[1] - step);
                if (direction === 'right') newBbox[3] = Math.min(1000, newBbox[3] + step);
                editBboxRef.current = newBbox;

                const source = editingImageObjRef.current;
                const newImg = await cutImageFromBase(source, newBbox);

                setEditingItem(prev => ({ ...prev, bbox: newBbox, tempImg: newImg }));

            }, [editingItem]);

            // [ê°œì„ ë¨] ê³ í™”ì§ˆ ë³€í™˜ì„ ì™„ì „ ë¹„ë™ê¸°ë¡œ ë¶„ë¦¬í•˜ì—¬ ë‹¤ë¥¸ í•­ëª© í¸ì§‘ ì¦‰ì‹œ ê°€ëŠ¥
            const endEditing = useCallback(() => {
                if (!editingItem) return;

                const { pageNum, itemIdx } = editingItem;
                const finalBbox = editBboxRef.current;
                const finalTempImg = editingItem.tempImg;

                const editKey = `${pageNum}-${itemIdx}`;
                userEditsRef.current[editKey] = { bbox: finalBbox, img: finalTempImg };

                // 1. UI ì¦‰ì‹œ ì—…ë°ì´íŠ¸ (ë¡œì»¬ ì´ë¯¸ì§€)
                setResults(prev => prev.map(p => {
                    if (p.pageNum !== pageNum) return p;
                    const newItems = p.items.map(it => {
                        if (it.originalItemIndex === itemIdx) {
                            return { ...it, bbox: finalBbox, img: finalTempImg, isHighResLoading: true };
                        }
                        return it;
                    });
                    return { ...p, items: newItems };
                }));

                // í¸ì§‘ ìƒíƒœ ì¦‰ì‹œ í•´ì œ (ë‹¤ë¥¸ í•­ëª© í¸ì§‘ ê°€ëŠ¥)
                setEditingItem(null);
                editBboxRef.current = null;
                editingImageObjRef.current = null;

                // 2. ë°±ê·¸ë¼ìš´ë“œ ê³ í™”ì§ˆ ë³€í™˜ (setTimeoutìœ¼ë¡œ ì™„ì „ ë¹„ë™ê¸° ë¶„ë¦¬)
                const currentJobId = pdfJobId || localStorage.getItem('last_pdf_job_id');
                if (currentJobId) {
                    setTimeout(async () => {
                        try {
                            const cropPayload = {
                                job_id: currentJobId,
                                page_num: pageNum,
                                items: [{ id: 'manual_edit', bbox: finalBbox }],
                                dpi: targetDpi
                            };
                            const res = await fetch("http://localhost:8000/crop_batch_items", {
                                method: "POST", headers: { "Content-Type": "application/json" },
                                body: JSON.stringify(cropPayload)
                            });

                            if (res.ok) {
                                const data = await res.json();
                                const highResImg = data.results[0]?.img;
                                if (highResImg) {
                                    userEditsRef.current[editKey] = { bbox: finalBbox, img: highResImg };
                                    saveEdits();

                                    setResults(prev => prev.map(p => {
                                        if (p.pageNum !== pageNum) return p;
                                        const newItems = p.items.map(it => {
                                            if (it.originalItemIndex === itemIdx) {
                                                return { ...it, img: highResImg, isHighResLoading: false };
                                            }
                                            return it;
                                        });
                                        return { ...p, items: newItems };
                                    }));
                                }
                            }
                        } catch (e) {
                            console.error("High Res Update Failed", e);
                            setResults(prev => prev.map(p => {
                                if (p.pageNum !== pageNum) return p;
                                const newItems = p.items.map(it => {
                                    if (it.originalItemIndex === itemIdx) return { ...it, isHighResLoading: false };
                                    return it;
                                });
                                return { ...p, items: newItems };
                            }));
                        }
                    }, 0); // setTimeout 0ìœ¼ë¡œ ì´ë²¤íŠ¸ ë£¨í”„ë¡œ ë¶„ë¦¬
                }
            }, [editingItem, targetDpi, pdfJobId]);

            const handleDeleteItem = useCallback((pageNum, itemIdx) => {
                if (!confirm("ì‚­ì œ?")) return;

                // 1. UI ì¦‰ì‹œ ì—…ë°ì´íŠ¸
                setResults(prev => prev.map(p => {
                    if (p.pageNum !== pageNum) return p;
                    return { ...p, items: p.items.filter((it) => it.originalItemIndex !== itemIdx) };
                }).filter(p => p.items.length > 0));

                // 2. ë¹„ë™ê¸° ì €ì¥
                deletedItemsRef.current.add(`${pageNum}-${itemIdx}`);
                saveEdits();
            }, []);

            const toggleSelectResult = useCallback((fName) => {
                setSelectedResultIds(prev => {
                    const next = new Set(prev);
                    if (next.has(fName)) next.delete(fName);
                    else next.add(fName);
                    return next;
                });
            }, []);

            const handlePreview = useCallback((img) => {
                setPreviewImg(img);
                setIsZoomed(false);
            }, []);

            const handleBatchSubmit = async () => {
                const validKeys = currentAiConfig.apiKeys.filter(k => k.key.trim()); if (!validKeys.length) return alert("API í‚¤ í•„ìš”");
                let targetPages = selectedIds.size ? pages.filter(p => selectedIds.has(p.id)) : [...pages];
                targetPages.sort((a, b) => a.pageNum - b.pageNum); if (!targetPages.length) return alert("í˜ì´ì§€ ì—†ìŒ");
                if (!confirm(`ì´ ${targetPages.length} í˜ì´ì§€ Batch ì „ì†¡?`)) return;
                setIsProcessing(true); log("ğŸ“¡ Batch ë°ì´í„° ì „ì†¡ ì¤‘...");
                try {
                    const batchItems = [];
                    for (const p of targetPages) {
                        let imgB64 = "";
                        if (p.is_server_processed) {
                            imgB64 = p.thumb.split(',')[1];
                        } else {
                            const dpiScale = Math.max(0.5, targetDpi / 72);
                            const pg = await p.pdfDoc.getPage(p.pageNum); const vp = pg.getViewport({ scale: dpiScale });
                            const cvs = document.createElement('canvas'); cvs.height = vp.height; cvs.width = vp.width;
                            await pg.render({ canvasContext: cvs.getContext('2d'), viewport: vp }).promise;
                            imgB64 = cvs.toDataURL('image/jpeg', 0.8).split(',')[1];
                        }
                        batchItems.push({ custom_id: `PAGE_${p.pageNum}`, prompt: currentPrompt.content + "\nOutput strictly Standard JSON.", image_base64: imgB64 });
                    }
                    const res = await fetch("http://localhost:8000/submit_batch", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ api_key: validKeys[0].key, model: currentAiConfig.model, items: batchItems }) });
                    if (!res.ok) throw new Error("ì„œë²„ í†µì‹  ì‹¤íŒ¨"); const data = await res.json();
                    setBatchId(data.batch_id); localStorage.setItem('last_batch_id', data.batch_id); alert(`âœ… Batch ID: ${data.batch_id}`);
                } catch (e) { log(`âŒ Batch ì—ëŸ¬: ${e.message}`); alert("ì‹¤íŒ¨. server.py ì‹¤í–‰ í™•ì¸"); }
                setIsProcessing(false);
            };

            const checkBatchStatus = async () => {
                if (!batchId) return; const validKeys = currentAiConfig.apiKeys.filter(k => k.key.trim()); if (!validKeys.length) return alert("API í‚¤ í•„ìš”");
                log("ğŸ”„ Batch í™•ì¸ ì¤‘...");
                try {
                    const res = await fetch(`http://localhost:8000/check_batch/${batchId}?api_key=${validKeys[0].key}`); const data = await res.json();
                    if (data.state === "COMPLETED") {
                        log("ğŸ‰ ì™„ë£Œ! ê²°ê³¼ ì²˜ë¦¬ ì¤‘...");
                        const newRawResults = [];
                        const currentJobId = pdfJobId || localStorage.getItem('last_pdf_job_id');

                        for (const item of data.results) {
                            try {
                                const jsonText = item.response.body.candidates[0].content.parts[0].text; const match = jsonText.match(/\{[\s\S]*\}/); if (!match) continue; const parsed = JSON.parse(match[0]);
                                const pageNum = parseInt(item.custom_id.replace('PAGE_', '')); const originalPage = pages.find(p => p.pageNum === pageNum);
                                if (originalPage && parsed.pages) {
                                    const rawItems = parsed.pages[0].items || [];
                                    const paddedItems = rawItems.map((it, idx) => {
                                        const [y1, x1, y2, x2] = it.bbox || [0, 0, 0, 0];
                                        const pTop = paddings.top;
                                        const pBot = paddings.bottom;
                                        const pLeft = paddings.left;
                                        const pRight = paddings.right;
                                        return {
                                            id: `batch_${idx}`,
                                            bbox: [
                                                Math.max(0, y1 - pTop),
                                                Math.max(0, x1 - pLeft),
                                                Math.min(1000, y2 + pBot),
                                                Math.min(1000, x2 + pRight)
                                            ]
                                        };
                                    });

                                    const cropPayload = {
                                        job_id: currentJobId,
                                        page_num: pageNum,
                                        items: paddedItems,
                                        dpi: targetDpi
                                    };

                                    const cropRes = await fetch("http://localhost:8000/crop_batch_items", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(cropPayload) });
                                    if (cropRes.ok) {
                                        const cropData = await cropRes.json();
                                        const validItems = [];
                                        for (let i = 0; i < rawItems.length; i++) {
                                            const raw = rawItems[i];
                                            const serverImg = cropData.results[i];
                                            const finalBbox = paddedItems[i].bbox;

                                            if (raw.type !== 'ignore' && serverImg && serverImg.img) {
                                                validItems.push({ ...raw, bbox: finalBbox, img: serverImg.img, raw_number: raw.number, raw_chapter: raw.header_text, fName: `BATCH_${Date.now()}_${i}.webp` });
                                            }
                                        }
                                        if (validItems.length) newRawResults.push({ pageNum, items: validItems });
                                    }
                                }
                            } catch (err) { console.error(err); }
                        }
                        setResults(recalculateContext(newRawResults)); log("âœ… ë¡œë“œ ì™„ë£Œ!"); setBatchId(null); localStorage.removeItem('last_batch_id');
                    } else if (data.state === "FAILED") { alert(`âŒ ì‹¤íŒ¨: ${data.error}`); setBatchId(null); localStorage.removeItem('last_batch_id'); } else { alert(`â³ ìƒíƒœ: ${data.state}`); }
                } catch (e) { log(`âŒ ì˜¤ë¥˜: ${e.message}`); }
            };

            const handleStop = () => {
                log("ğŸ›‘ ì¤‘ë‹¨ ìš”ì²­... ì•ˆì „í•˜ê²Œ ì •ë¦¬ ì¤‘...");
                stopRef.current = true;

                if (abortControllerRef.current) {
                    abortControllerRef.current.abort();
                }

                setIsProcessing(false);
            };

            const startProcessing = async () => {
                const validKeys = currentAiConfig.apiKeys.filter(k => k.key.trim());
                if (!validKeys.length) return alert("API í‚¤ ì…ë ¥ í•„ìš”");

                let allTargetPages = selectedIds.size ? pages.filter(p => selectedIds.has(p.id)) : [...pages];
                allTargetPages.sort((a, b) => a.pageNum - b.pageNum);

                if (!allTargetPages.length) return alert("í˜ì´ì§€ ì—†ìŒ");

                const existingPageNums = new Set(results.map(r => r.pageNum));
                const pendingPages = allTargetPages.filter(p => !existingPageNums.has(p.pageNum));

                if (pendingPages.length === 0) return alert("ëª¨ë“  í˜ì´ì§€ê°€ ì´ë¯¸ ì²˜ë¦¬ë˜ì—ˆìŠµë‹ˆë‹¤.");

                const resumeMsg = results.length > 0 ? `ê¸°ì¡´ ${results.length}ì¥ì€ ê±´ë„ˆë›°ê³ , ${pendingPages.length}ì¥ë§Œ ì²˜ë¦¬í•©ë‹ˆë‹¤.` : `ì´ ${pendingPages.length}í˜ì´ì§€ ë¶„ì„ ì‹œì‘`;
                log(`ğŸš€ ${resumeMsg}`);

                if (!guardActive) toggleGuard(true);

                setIsProcessing(true);
                stopRef.current = false;

                if (abortControllerRef.current) abortControllerRef.current.abort();
                abortControllerRef.current = new AbortController();

                const queue = [...pendingPages];
                let allRawResults = [...results];
                let processedCount = 0;
                const totalCount = pendingPages.length;

                const updateDisplay = () => {
                    if (stopRef.current) return;
                    try { setResults(recalculateContext(allRawResults)); } catch (e) { console.error("Display Update Error"); }
                };

                const runWorker = async (workerId) => {
                    while (queue.length > 0 && !stopRef.current) {
                        // [FIXED] batchSize ì ìš©: ì—¬ëŸ¬ í˜ì´ì§€ë¥¼ í•œ ë²ˆì— ì²˜ë¦¬
                        const batch = queue.splice(0, Math.min(batchSize, queue.length));
                        if (!batch.length) break;

                        let success = false;
                        let retryCount = 0;
                        let failedKeyCount = 0;

                        while (!success && !stopRef.current) {
                            if (failedKeyCount >= validKeys.length) {
                                stopRef.current = true;
                                setIsProcessing(false);
                                alert("ğŸ›‘ ëª¨ë“  API í‚¤ë¥¼ ì‹œë„í–ˆìœ¼ë‚˜ 429(Rate Limit) ë“±ì˜ ì‚¬ìœ ë¡œ ì‹¤íŒ¨í•˜ì—¬ ì‘ì—…ì„ ì¤‘ë‹¨í•©ë‹ˆë‹¤.");
                                return;
                            }

                            try {
                                lastKeyIdxRef.current = (lastKeyIdxRef.current + 1) % validKeys.length;
                                const keyData = validKeys[lastKeyIdxRef.current];

                                const res = await processBatchWorker(
                                    batch, // ë°°ì¹˜ ì „ì²´ ì „ë‹¬
                                    currentAiConfig,
                                    keyData,
                                    currentPrompt.content,
                                    abortControllerRef.current.signal
                                );

                                if (Array.isArray(res)) {
                                    if (res.length > 0) {
                                        allRawResults.push(...res);
                                    }
                                    processedCount += batch.length;
                                    const pageNumsStr = batch.map(p => p.pageNum).join(',');
                                    log(`âœ… [${Math.round((processedCount / totalCount) * 100)}%] p.${pageNumsStr} ì™„ë£Œ (${batch.length}ì¥ ë°°ì¹˜)`);
                                    updateDisplay();
                                    success = true;
                                } else if (res === 'RATE_LIMIT') {
                                    failedKeyCount++;
                                    if (validKeys.length > 1) {
                                        log(`âš¡ 429(Too Many Requests) - ëŒ€ê¸° ì—†ì´ ë‹¤ìŒ í‚¤ë¡œ ì¦‰ì‹œ ì „í™˜`);
                                        await delay(200);
                                        continue;
                                    } else {
                                        retryCount++;
                                        const waitTime = Math.min(2000 * retryCount, 20000);
                                        log(`âš ï¸ 429 ê°ì§€ (í‚¤ê°€ 1ê°œë¿ì´ë¼ ëŒ€ê¸°í•¨) - ${waitTime / 1000}ì´ˆ ëŒ€ê¸°`);
                                        await delay(waitTime);
                                    }
                                } else {
                                    failedKeyCount++;
                                    retryCount++;
                                    const waitTime = Math.min(1000 * retryCount, 10000);
                                    const pageNumsStr = batch.map(p => p.pageNum).join(',');
                                    log(`âš ï¸ p.${pageNumsStr} ì‹¤íŒ¨ (ì¬ì‹œë„ ${retryCount}íšŒ, ${waitTime / 1000}ì´ˆ ëŒ€ê¸°...)`);
                                    await delay(waitTime);
                                }
                            } catch (err) {
                                if (stopRef.current) break;
                                failedKeyCount++;
                                log(`âŒ ì‹œìŠ¤í…œ ì—ëŸ¬: ${err.message}`);
                                await delay(2000);
                            }
                        }
                    }
                };

                const workers = Array.from({ length: concurrency }, (_, i) => runWorker(i));

                try {
                    await Promise.all(workers);
                } catch (e) {
                    console.error("Batch Process Error", e);
                } finally {
                    if (stopRef.current) log("ğŸ›‘ ì‘ì—…ì´ ì•ˆì „í•˜ê²Œ ì¤‘ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤.");
                    else log("ğŸ ëª¨ë“  í˜ì´ì§€ ì‘ì—… ì™„ë£Œ");
                    setIsProcessing(false);
                }
            };

            // [ê°œì„ ë¨] ì»¤ìŠ¤í…€ í•„ë“œ ê¸°ë°˜ ZIP ë‹¤ìš´ë¡œë“œ - ì±•í„° ê·¸ë£¹ ë‚´ ì¼ê´€ëœ ì±•í„°ëª… ì‚¬ìš©
            const downloadZip = async () => {
                const zip = new JSZip();
                const enabledFields = ankiFields.filter(f => f.enabled);
                const headerLine = '# Anki Import\n# ' + enabledFields.map(f => f.name).join('\t') + '\n';
                let fullTxt = headerLine;
                const grouped = {};
                const chapterTexts = {};

                const sortedResults = [...results].sort((a, b) => a.pageNum - b.pageNum);

                // í—¬í¼: ì±•í„°ëª…ì—ì„œ ê·¸ë£¹í‚¤ ì¶”ì¶œ (ì‚¬ìš©ì ì •ì˜ ì •ê·œì‹ ì‚¬ìš©)
                const getChapterGroupKey = (chapName) => {
                    const trimmed = (chapName || "").trim();

                    // ì‚¬ìš©ì ì •ì˜ ì •ê·œì‹ íŒ¨í„´ ìˆœì°¨ ì ìš©
                    for (const pattern of regexPatterns) {
                        if (!pattern.enabled || !pattern.regex) continue;
                        try {
                            const regex = new RegExp(pattern.regex);
                            const match = trimmed.match(regex);
                            if (match) {
                                // ìº¡ì²˜ ê·¸ë£¹ì´ ìˆìœ¼ë©´ ì¡°í•©, ì—†ìœ¼ë©´ ì „ì²´ ë§¤ì¹˜ ë°˜í™˜
                                if (match.length > 1) {
                                    return match.slice(1).filter(Boolean).join('');
                                }
                                return match[0];
                            }
                        } catch (e) {
                            console.warn(`Invalid regex pattern: ${pattern.regex}`, e);
                        }
                    }

                    // íŒ¨í„´ì´ ì—†ê±°ë‚˜ ë§¤ì¹˜ë˜ì§€ ì•Šìœ¼ë©´ íŠ¹ìˆ˜ë¬¸ì ì œê±° í›„ ë°˜í™˜
                    return trimmed.replace(/[\s_]+/g, '_');
                };

                // 1ë‹¨ê³„: ë¨¼ì € ëª¨ë“  ì•„ì´í…œì„ ìˆœíšŒí•˜ë©´ì„œ ì±•í„° ê·¸ë£¹ë³„ ëŒ€í‘œ ì±•í„°ëª… ê²°ì •
                const chapterGroupTitles = {};
                sortedResults.forEach(res => {
                    res.items.forEach(it => {
                        const chapterName = it.chapter || "Uncategorized";
                        const groupKey = getChapterGroupKey(chapterName);

                        if (!chapterGroupTitles[groupKey]) {
                            chapterGroupTitles[groupKey] = chapterName;
                        } else {
                            const curTitle = chapterGroupTitles[groupKey];

                            // 1. í˜„ì¬ íƒ€ì´í‹€ì´ ì–¸ë”ë°”('_')ê°€ ë§ì€ë° ìƒˆ ì´ë¦„ì€ ê¹”ë”í•˜ë©´ êµì²´ (ì˜ˆ: "ì œ_1_í¸" -> "ì œ1í¸ í–‰ì •ë²•")
                            const curUnder = (curTitle.match(/_/g) || []).length;
                            const newUnder = (chapterName.match(/_/g) || []).length;

                            if (newUnder < curUnder) {
                                chapterGroupTitles[groupKey] = chapterName;
                            }
                            // 2. ì–¸ë”ë°” ê°œìˆ˜ê°€ ë¹„ìŠ·í•˜ë©´ ë” ê¸´(ìƒì„¸í•œ) ì„¤ëª…ì´ ìˆëŠ” ê²ƒ ì„ í˜¸
                            else if (newUnder === curUnder && chapterName.length > curTitle.length) {
                                chapterGroupTitles[groupKey] = chapterName;
                            }
                        }
                    });
                });

                // 2ë‹¨ê³„: ê·¸ë£¹í™” - ë¬¸ì œ ë²ˆí˜¸ë³„ë¡œ ëª¨ìœ¼ë˜, ì±•í„°ëª…ì€ ê·¸ë£¹ ëŒ€í‘œ ì±•í„°ëª… ì‚¬ìš©
                sortedResults.forEach(res => {
                    res.items.forEach(it => {
                        const originalChapter = it.chapter || "Uncategorized";
                        const groupKey = getChapterGroupKey(originalChapter);
                        // ê·¸ë£¹ì˜ ëŒ€í‘œ ì±•í„°ëª… ì‚¬ìš© (ì¼ê´€ì„± ë³´ì¥)
                        const unifiedChapter = chapterGroupTitles[groupKey] || originalChapter;

                        const key = `${unifiedChapter}_${it.number}`;
                        if (!grouped[key]) grouped[key] = { q: [], s: [], chap: unifiedChapter, groupKey: groupKey, customFields: {} };
                        if (it.type === 'question') grouped[key].q.push(it);
                        else grouped[key].s.push(it);
                        // ì»¤ìŠ¤í…€ í•„ë“œ ë°ì´í„° ìˆ˜ì§‘
                        if (it.customFields) {
                            Object.assign(grouped[key].customFields, it.customFields);
                        }
                    });
                });

                // 3ë‹¨ê³„: ê° ê·¸ë£¹ì„ ìˆœíšŒí•˜ë©´ì„œ í–‰ ìƒì„±
                Object.keys(grouped).forEach(k => {
                    const g = grouped[k];
                    if (!g.q.length) return;

                    const fieldValues = [];

                    enabledFields.forEach(field => {
                        if (field.type === 'question' && field.isImage) {
                            let html = "";
                            g.q.forEach((i, idx) => {
                                const ext = i.img.includes('image/jpeg') ? 'jpg' : 'png';
                                const safeChap = g.chap.trim().replace(/\s+/g, '_').replace(/[\/\\?%*:|"<>]/g, '') || "NoChapter";
                                const qNum = i.number || "0";
                                const newName = `${safeChap}_ë¬¸ì œ_${qNum}_${idx + 1}.${ext}`;
                                zip.file(newName, i.img.split(',')[1], { base64: true });
                                html += `<img src="${newName}"><br>`;
                            });
                            fieldValues.push(html || " ");
                        } else if (field.type === 'solution' && field.isImage) {
                            let html = "";
                            g.s.forEach((i, idx) => {
                                const ext = i.img.includes('image/jpeg') ? 'jpg' : 'png';
                                const safeChap = g.chap.trim().replace(/\s+/g, '_').replace(/[\/\\?%*:|"<>]/g, '') || "NoChapter";
                                const qNum = i.number || "0";
                                const newName = `${safeChap}_í•´ì„¤_${qNum}_${idx + 1}.${ext}`;
                                zip.file(newName, i.img.split(',')[1], { base64: true });
                                html += `<img src="${newName}"><br>`;
                            });
                            fieldValues.push(html || " ");
                        } else if (field.type === 'tag') {
                            // í†µì¼ëœ ì±•í„°ëª… ì‚¬ìš©
                            fieldValues.push(g.chap);
                        } else if (field.type === 'custom') {
                            // ì»¤ìŠ¤í…€ í•„ë“œ ì²˜ë¦¬
                            fieldValues.push(g.customFields[field.id] || field.defaultValue || " ");
                        } else {
                            fieldValues.push(" ");
                        }
                    });

                    const line = fieldValues.join('\t') + '\n';
                    fullTxt += line;

                    // ì±•í„° ê·¸ë£¹ë³„ íŒŒì¼ ìƒì„±ì„ ìœ„í•œ ë°ì´í„° ìˆ˜ì§‘
                    const groupKey = g.groupKey;

                    if (!chapterTexts[groupKey]) {
                        chapterTexts[groupKey] = {
                            rows: [],
                            fullTitle: g.chap
                        };
                    }
                    chapterTexts[groupKey].rows.push(line);
                });

                zip.file("anki_full_import.txt", fullTxt);
                const chapterFolder = zip.folder("Chapters_Split");

                // [ê°œì„ ë¨] ì±•í„° í‚¤ë¥¼ ìˆ«ì ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬ (ì œ1í¸, ì œ2í¸, ... ì œ10í¸ ìˆœì„œ ë³´ì¥)
                const sortedChapterKeys = Object.keys(chapterTexts).sort((a, b) => {
                    const matchA = a.match(/^ì œ(\d+)([í¸ì¥ê°•])/);
                    const matchB = b.match(/^ì œ(\d+)([í¸ì¥ê°•])/);
                    if (matchA && matchB) {
                        // ê°™ì€ ë‹¨ìœ„(í¸/ì¥/ê°•)ë¼ë¦¬ ë¨¼ì €, ê·¸ ì•ˆì—ì„œ ìˆ«ì ìˆœ
                        const unitOrder = { 'í¸': 1, 'ì¥': 2, 'ê°•': 3 };
                        const unitA = unitOrder[matchA[2]] || 99;
                        const unitB = unitOrder[matchB[2]] || 99;
                        if (unitA !== unitB) return unitA - unitB;
                        return parseInt(matchA[1], 10) - parseInt(matchB[1], 10);
                    }
                    if (matchA) return -1;
                    if (matchB) return 1;
                    return a.localeCompare(b, 'ko');
                });

                sortedChapterKeys.forEach(key => {
                    const group = chapterTexts[key];

                    // [ê°œì„ ë¨] íŒŒì¼ëª…/ë± ì´ë¦„ ì•ë¶€ë¶„ ì •ê·œí™” (ì œ_4_í¸ -> ì œ4í¸)
                    let cleanTitle = group.fullTitle.trim()
                        .replace(/^ì œ[\s_]*(\d+)[\s_]*([í¸ì¥ê°•])[\s_]*/, 'ì œ$1$2 ')
                        .trim();

                    const deckName = cleanTitle.replace(/[\/\\?%*:|"<>]/g, '');
                    const content = `# deck: ${deckName}\n` + headerLine + group.rows.join('');

                    // íŒŒì¼ëª…: ìˆ«ì ì •ë ¬ì„ ìœ„í•´ 2ìë¦¬ íŒ¨ë”© ì ìš© (ì œ1í¸ -> ì œ01í¸)
                    let safeTitle = cleanTitle
                        .replace(/^ì œ(\d)([í¸ì¥ê°•])/, 'ì œ0$1$2')  // í•œìë¦¬ ìˆ«ìë©´ 0 ë¶™ì´ê¸°
                        .replace(/\s+/g, '_')
                        .replace(/[\/\\?%*:|"<>]/g, '');

                    chapterFolder.file(`${safeTitle}.txt`, content);
                });

                const blob = await zip.generateAsync({ type: "blob" });
                const link = document.createElement("a");
                link.href = URL.createObjectURL(blob);
                link.download = "Anki_Result.zip";
                link.click();
            };
            const cancelBatch = () => { if (confirm('ì·¨ì†Œí•˜ì‹œê² ìŠµë‹ˆê¹Œ? (ì„œë²„ ì‘ì—…ì€ ê³„ì†ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤)')) { setBatchId(null); localStorage.removeItem('last_batch_id'); } };

            const selectAllResult = () => {
                const allIds = new Set();
                results.forEach(pg => pg.items.forEach(it => allIds.add(it.fName)));
                setSelectedResultIds(allIds);
            };

            const deselectAllResult = () => setSelectedResultIds(new Set());

            const deleteSelectedResult = () => {
                if (!selectedResultIds.size) return;
                if (!confirm(`${selectedResultIds.size}ê°œ í•­ëª©ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) return;

                // 1. UI ì¦‰ì‹œ ì—…ë°ì´íŠ¸
                setResults(prev => prev.map(pg => ({
                    ...pg,
                    items: pg.items.filter(it => !selectedResultIds.has(it.fName))
                })).filter(pg => pg.items.length > 0));

                // 2. ë¹„ë™ê¸° ì €ì¥
                results.forEach(pg => {
                    pg.items.forEach(it => {
                        if (selectedResultIds.has(it.fName)) {
                            deletedItemsRef.current.add(`${pg.pageNum}-${it.originalItemIndex}`);
                        }
                    });
                });

                saveEdits();
                setSelectedResultIds(new Set());
            };

            // [FIXED] ì¬ì‹¤í–‰ ë¡œì§ - ê°œì„ ëœ ì—ëŸ¬ í•¸ë“¤ë§
            const handleRetry = async (pageNum) => {
                if (retryingPage) return;
                setRetryingPage(pageNum);
                log(`ğŸ”„ p.${pageNum} ì¬ë¶„ì„ ì¤€ë¹„...`);

                // 1. í˜ì´ì§€ ê°ì²´ ì°¾ê¸°
                let targetPage = pages.find(p => p.pageNum === pageNum);

                // 2. ë§Œì•½ í˜ì´ì§€(ì´ë¯¸ì§€ ë°ì´í„°)ê°€ ì—†ë‹¤ë©´(ìƒˆë¡œê³ ì¹¨ ì§í›„ ë“±), ì„œë²„ì—ì„œ Job IDë¥¼ ì´ìš©í•´ ë³µêµ¬ ì‹œë„
                if (!targetPage) {
                    const lastJobId = pdfJobId || localStorage.getItem('last_pdf_job_id');
                    if (lastJobId) {
                        try {
                            log(`âš ï¸ ì›ë³¸ ë°ì´í„° ë³µêµ¬ ì‹œë„ (p.${pageNum}, DPI=${pdfDpi})...`);
                            const imgRes = await fetch("http://localhost:8000/get_page_image", {
                                method: "POST", headers: { "Content-Type": "application/json" },
                                body: JSON.stringify({ job_id: lastJobId, page_num: pageNum, dpi: pdfDpi })
                            });

                            if (imgRes.ok) {
                                const imgData = await imgRes.json();
                                if (imgData && imgData.img) {
                                    targetPage = {
                                        pageNum: pageNum,
                                        is_server_processed: true,
                                        thumb: imgData.img,
                                        id: `restored_${pageNum}`
                                    };
                                    log(`âœ… p.${pageNum} ì´ë¯¸ì§€ ë³µêµ¬ ì„±ê³µ`);
                                } else {
                                    log(`âŒ p.${pageNum} ì„œë²„ ì‘ë‹µì— ì´ë¯¸ì§€ ì—†ìŒ`);
                                }
                            } else {
                                const errText = await imgRes.text();
                                log(`âŒ ì´ë¯¸ì§€ ë³µêµ¬ ì‹¤íŒ¨: ${errText}`);
                            }
                        } catch (e) {
                            console.error("Restore failed", e);
                            log(`âŒ ì´ë¯¸ì§€ ë³µêµ¬ ì¤‘ ì—ëŸ¬: ${e.message}`);
                        }
                    } else {
                        log(`âŒ Job IDê°€ ì—†ì–´ ë³µêµ¬ ë¶ˆê°€ëŠ¥`);
                    }
                }

                if (!targetPage) {
                    alert("ì›ë³¸ í˜ì´ì§€ ë°ì´í„°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. PDFë¥¼ ë‹¤ì‹œ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”.");
                    log("âŒ ì‹¤íŒ¨: ì›ë³¸ ë°ì´í„° ì—†ìŒ");
                    setRetryingPage(null);
                    return;
                }

                const validKeys = currentAiConfig.apiKeys.filter(k => k.key.trim());
                if (!validKeys.length) {
                    alert("API í‚¤ê°€ ì—†ìŠµë‹ˆë‹¤.");
                    log("âŒ ìœ íš¨í•œ API í‚¤ ì—†ìŒ");
                    setRetryingPage(null);
                    return;
                }

                // 3. í•´ë‹¹ í˜ì´ì§€ì˜ ì‚­ì œ ì´ë ¥ ë° í¸ì§‘ ì´ë ¥ ì´ˆê¸°í™”
                try {
                    const newDeleted = new Set([...deletedItemsRef.current].filter(k => !k.startsWith(`${pageNum}-`)));
                    deletedItemsRef.current = newDeleted;

                    const newEdits = { ...userEditsRef.current };
                    Object.keys(newEdits).forEach(k => { if (k.startsWith(`${pageNum}-`)) delete newEdits[k]; });
                    userEditsRef.current = newEdits;

                    await saveEdits(); // DB ì¦‰ì‹œ ë°˜ì˜
                    log(`ğŸ§¹ p.${pageNum} ê³¼ê±° ì´ë ¥(ì‚­ì œ/ìˆ˜ì •) ì´ˆê¸°í™” ì™„ë£Œ`);
                } catch (e) { console.error("Clean history failed", e); }

                // 4. ì¬ì‹¤í–‰
                try {
                    log(`ğŸ”„ p.${pageNum} ì¬ë¶„ì„ ì‹œì‘...`);
                    const res = await processBatchWorker([targetPage], currentAiConfig, validKeys[0], currentPrompt.content, new AbortController().signal);

                    if (res && res.length > 0) {
                        setResults(prev => recalculateContext([...prev.filter(p => p.pageNum !== pageNum), ...res]));
                        log(`âœ… p.${pageNum} ì¬ë¶„ì„ ì™„ë£Œ!`);
                    } else if (res === 'RATE_LIMIT') {
                        log(`âš ï¸ 429 Rate Limit ë°œìƒ (ì¬ì‹œë„ ì‹¤íŒ¨)`);
                        alert("API ì‚¬ìš©ëŸ‰ ì œí•œ(429)ì´ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
                    } else {
                        log(`âš ï¸ p.${pageNum} ê²°ê³¼ ì—†ìŒ (AIê°€ ì•„ì´í…œì„ ì°¾ì§€ ëª»í•¨)`);
                    }
                } catch (e) {
                    console.error(e);
                    log(`âŒ ì¬ì‹œë„ ì—ëŸ¬: ${e.message}`);
                    alert("ì¬ì‹œë„ ì‹¤íŒ¨ (ë¡œê·¸ í™•ì¸)");
                } finally {
                    setTimeout(() => setRetryingPage(null), 100);
                }
            };

            // [NEW] ì™„ì „ ì´ˆê¸°í™” í•¨ìˆ˜ (ë¸”ë™ë¦¬ìŠ¤íŠ¸ê¹Œì§€ ì‚­ì œ)
            const handleFullReset = async () => {
                if (!confirm('ëª¨ë“  ê²°ê³¼ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ? (ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤)')) return;

                // 1. ë©”ëª¨ë¦¬ ì´ˆê¸°í™”
                setResults([]);
                deletedItemsRef.current = new Set();
                userEditsRef.current = {};

                // 2. ì €ì¥ì†Œ ì´ˆê¸°í™”
                localStorage.removeItem('auto_saved_results');
                await idbSave('results', []);
                await idbSave('user_edits', {});
                await idbSave('deleted_items', []);

                log("ğŸ§¹ ëª¨ë“  ë°ì´í„°ê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.");
            };

            const [isDragging, setIsDragging] = useState(false);
            const [dragStartIndex, setDragStartIndex] = useState(null);
            const [initialSelectedIds, setInitialSelectedIds] = useState(new Set());
            useEffect(() => { const up = () => { setIsDragging(false); setDragStartIndex(null); }; window.addEventListener('mouseup', up); return () => window.removeEventListener('mouseup', up); }, []);

            return (
                <ErrorBoundary>
                    <div className={`max-w-[1800px] mx-auto p-4 md:p-6 space-y-6 transition-all duration-300 ${guardActive ? 'guard-active rounded-[2.5rem]' : ''}`}>
                        <header className="bg-white p-6 rounded-[2rem] shadow-xl flex flex-col md:flex-row justify-between items-center gap-4 border border-indigo-50">
                            <div className="flex items-center gap-4">
                                <div className="p-4 bg-indigo-600 rounded-2xl text-white shadow-lg"><LucideIcon name="scissors" size={32} /></div>
                                <div>
                                    <h1 className="text-2xl font-black italic text-slate-800">{t.title}</h1>
                                    <div className="flex items-center gap-2">
                                        <select value={language} onChange={e => setLanguage(e.target.value)} className="text-xs bg-slate-100 border border-slate-200 rounded-full px-2 py-0.5 font-bold text-slate-600 cursor-pointer">
                                            <option value="ko">ğŸ‡°ğŸ‡· í•œêµ­ì–´</option>
                                            <option value="en">ğŸ‡ºğŸ‡¸ English</option>
                                            <option value="zh">ğŸ‡¨ğŸ‡³ ä¸­æ–‡</option>
                                        </select>
                                        <div className={`flex items-center gap-1.5 px-2 py-0.5 rounded-full border ${serverStatus ? 'bg-emerald-50 border-emerald-200 text-emerald-600' : 'bg-slate-100 border-slate-200 text-slate-400'} transition-all`}>
                                            <div className={`w-1.5 h-1.5 rounded-full ${serverStatus ? 'bg-emerald-500 animate-pulse' : 'bg-slate-400'}`}></div>
                                            <span className="text-[9px] font-bold">{serverStatus ? t.serverOn : t.serverOff}</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div className="flex gap-2 items-center">
                                <div className="flex flex-col items-end mr-2">
                                    <span className={`text-[10px] font-bold transition-colors ${saveStatus === 'saving' ? 'text-indigo-500 animate-pulse' : saveStatus === 'error' ? 'text-rose-500' : 'text-slate-300'}`}>
                                        {saveStatus === 'saving' ? t.saving : saveStatus === 'error' ? t.saveFailed : t.autoSaved}
                                    </span>
                                </div>
                                <button onClick={() => toggleGuard()} className={`px-4 py-2 rounded-xl text-xs font-bold shadow-md transition-all flex items-center gap-2 ${guardActive ? 'bg-emerald-500 text-white' : 'bg-white border border-slate-200 text-slate-600 hover:bg-slate-50'}`}>
                                    <LucideIcon name={guardActive ? "shield-check" : "shield-off"} size={14} />
                                    {guardActive ? t.systemProtectOn : t.systemProtectOff}
                                </button>
                                <button
                                    onClick={async () => {
                                        if (!serverStatus) return alert('ì„œë²„ê°€ ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                                        if (!confirm(`ì„ì‹œ PDF ${tempPdfCount}ê°œë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) return;
                                        try {
                                            const res = await fetch('http://localhost:8000/clear_temp_pdfs', { method: 'DELETE' });
                                            if (res.ok) {
                                                const data = await res.json();
                                                setTempPdfCount(0);
                                                log(`ğŸ—‘ï¸ ì„ì‹œ íŒŒì¼ ${data.deleted_count}ê°œ ì‚­ì œ ì™„ë£Œ`);
                                                alert(`${data.deleted_count}ê°œ íŒŒì¼ ì‚­ì œ ì™„ë£Œ`);
                                            }
                                        } catch (e) { alert('ì‚­ì œ ì‹¤íŒ¨: ' + e.message); }
                                    }}
                                    disabled={!serverStatus || tempPdfCount === 0}
                                    className="px-3 py-2 rounded-xl text-xs font-bold shadow-md transition-all flex items-center gap-2 bg-orange-50 border border-orange-200 text-orange-600 hover:bg-orange-100 disabled:opacity-40 disabled:cursor-not-allowed"
                                    title="ì„œë²„ì˜ ì„ì‹œ PDF íŒŒì¼ì„ ì‚­ì œí•©ë‹ˆë‹¤"
                                >
                                    <LucideIcon name="trash" size={14} />
                                    Temp ({tempPdfCount})
                                </button>
                                <div className="w-px h-8 bg-slate-200"></div>
                                {batchId ? (
                                    <div className="flex items-center gap-2">
                                        <button onClick={checkBatchStatus} className="bg-emerald-500 text-white px-4 py-2 rounded-xl text-xs font-bold shadow-md flex items-center gap-2 hover:bg-emerald-600">
                                            <LucideIcon name="refresh-cw" size={14} /> {t.batchCheck}
                                        </button>
                                        <button onClick={cancelBatch} className="bg-slate-100 text-slate-500 px-3 py-2 rounded-xl text-xs font-bold hover:bg-slate-200">
                                            <LucideIcon name="x" size={14} />
                                        </button>
                                    </div>
                                ) : (
                                    <button onClick={handleBatchSubmit} disabled={isLoadingPdf || !pages.length || isProcessing} className="bg-violet-600 text-white px-4 py-2 rounded-xl text-xs font-bold shadow-md flex items-center gap-2 hover:bg-violet-700 disabled:bg-slate-300">
                                        <LucideIcon name="send" size={14} /> {t.batchSend}
                                    </button>
                                )}
                                {isProcessing ? <button onClick={handleStop} className="bg-rose-500 text-white px-10 py-4 rounded-2xl font-bold shadow-lg animate-pulse hover:bg-rose-600 transition-colors flex items-center gap-2"><LucideIcon name="octagon" size={14} /> {t.stop}</button> : <button onClick={startProcessing} disabled={isLoadingPdf || !pages.length || isProcessing} className="bg-indigo-600 text-white px-10 py-4 rounded-2xl font-bold hover:scale-105 shadow-xl transition-all disabled:bg-slate-300">
                                    {results.length > 0 ? `${t.continueFrom} (p.${Math.max(...results.map(r => r.pageNum)) + 1})` : t.startRealtime}
                                </button>}
                            </div>
                        </header>
                        <div className="grid grid-cols-1 lg:grid-cols-12 gap-6">
                            <aside className="lg:col-span-3 space-y-6">
                                <div className="bg-white p-5 rounded-[2rem] shadow-xl space-y-4 border border-indigo-50"><div className="flex justify-between items-center border-b border-indigo-100 pb-2"><h2 className="font-bold flex items-center gap-2 text-indigo-900"><LucideIcon name="cpu" /> {t.aiEngine}</h2><div className="flex gap-1"><button onClick={() => aiFileRef.current.click()} className="text-[10px] bg-indigo-50 text-indigo-600 px-2 py-1 rounded hover:bg-indigo-100"><LucideIcon name="download" size={10} /></button><button onClick={exportAiProfiles} className="text-[10px] bg-indigo-50 text-indigo-600 px-2 py-1 rounded hover:bg-indigo-100"><span className="font-bold">ALL</span><LucideIcon name="upload" size={10} /></button><input type="file" className="hidden" ref={aiFileRef} onChange={importAiProfiles} accept=".json" /></div></div><div className="flex flex-wrap gap-1 -mt-2"><button onClick={saveAiProfile} className="flex-1 text-[10px] bg-indigo-600 text-white px-2 py-1.5 rounded hover:bg-indigo-700">{t.save}</button><button onClick={exportCurrentAiProfile} className="flex-1 text-[10px] bg-white border border-slate-200 text-slate-600 px-2 py-1.5 rounded hover:bg-slate-50">{t.export1}</button><button onClick={deleteAiProfile} disabled={currentAiConfig.id === 'temp'} className="text-[10px] bg-rose-100 text-rose-600 px-3 py-1.5 rounded hover:bg-rose-200 disabled:opacity-30 disabled:cursor-not-allowed">{t.delete}</button></div><div className="input-group"><label>{t.profile}</label><select onChange={loadAiProfile} value={currentAiConfig.id} className="font-bold text-indigo-600"><option value="new">{t.newSetting}</option>{aiProfiles.map(p => <option key={p.id} value={p.id}>{p.name}</option>)}</select></div><div className="space-y-3 p-3 bg-slate-50 rounded-xl border"><div className="input-group"><label>{t.provider}</label><select value={currentAiConfig.providerType} onChange={e => { const type = e.target.value; const def = PROVIDER_TYPES.find(t => t.id === type); setCurrentAiConfig({ ...currentAiConfig, providerType: type, baseUrl: def.defaultUrl, model: def.defaultModel }); }}>{PROVIDER_TYPES.map(t => <option key={t.id} value={t.id}>{t.name}</option>)}</select></div><div className="input-group"><label>{t.model}</label><input value={currentAiConfig.model} onChange={e => setCurrentAiConfig({ ...currentAiConfig, model: e.target.value })} placeholder="" /></div><div className="input-group"><label>{t.baseUrl}</label><input value={currentAiConfig.baseUrl} onChange={e => setCurrentAiConfig({ ...currentAiConfig, baseUrl: e.target.value })} placeholder="https://api..." className="font-mono text-[10px] text-slate-400" /></div><div className="input-group"><label className="flex justify-between">{t.apiKeys} <button onClick={addKey} className="text-[9px] text-indigo-500">{t.addKey}</button></label><div className="space-y-2 max-h-40 overflow-y-auto custom-scrollbar">{currentAiConfig.apiKeys.map((k, idx) => (<div key={idx} className="flex flex-col gap-1 bg-white p-2 rounded border"><div className="flex gap-1"><input type="text" value={k.name} onChange={e => updateKey(idx, 'name', e.target.value)} placeholder={t.alias} className="w-1/3 text-[10px] font-bold text-indigo-500 bg-indigo-50/50" /><button onClick={() => removeKey(idx)} className="text-slate-300 hover:text-rose-500 px-1 ml-auto"><LucideIcon name="trash-2" size={12} /></button></div><input type="password" value={k.key} onChange={e => updateKey(idx, 'key', e.target.value)} placeholder="sk-..." className="w-full font-mono text-[10px]" /></div>))}</div></div></div></div>
                                <div className="bg-white p-5 rounded-[2rem] shadow-xl space-y-4"><div className="flex justify-between items-center border-b pb-2"><h2 className="font-bold flex items-center gap-2"><LucideIcon name="message-square" /> {t.prompt}</h2><div className="flex gap-1"><button onClick={() => promptFileRef.current.click()} className="text-[10px] bg-slate-100 text-slate-600 px-2 py-1 rounded hover:bg-slate-200"><LucideIcon name="download" size={10} /></button><button onClick={exportPrompts} className="text-[10px] bg-slate-100 text-slate-600 px-2 py-1 rounded hover:bg-slate-200"><span className="font-bold">ALL</span><LucideIcon name="upload" size={10} /></button><input type="file" className="hidden" ref={promptFileRef} onChange={importPrompts} accept=".json" /></div></div><div className="flex flex-wrap gap-1 -mt-2"><button onClick={updateCurrentPrompt} className="flex-1 text-[10px] bg-indigo-600 text-white px-2 py-1.5 rounded hover:bg-indigo-700">{t.save}</button><button onClick={exportCurrentPrompt} className="flex-1 text-[10px] bg-white border border-slate-200 text-slate-600 px-2 py-1.5 rounded hover:bg-slate-50">{t.export1}</button><button onClick={deletePromptProfile} disabled={currentPrompt.id.startsWith('default')} className="text-[10px] bg-rose-100 text-rose-600 px-3 py-1.5 rounded hover:bg-rose-200 disabled:opacity-30 disabled:cursor-not-allowed">{t.delete}</button></div><div className="flex gap-1"><button onClick={savePromptAsNew} className="flex-1 text-[10px] bg-slate-50 border border-slate-200 text-slate-600 px-2 py-1.5 rounded hover:bg-slate-100">{t.saveAsNew}</button><button onClick={createNewPrompt} className="flex-1 text-[10px] bg-slate-50 border border-slate-200 text-slate-600 px-2 py-1.5 rounded hover:bg-slate-100">{t.newPrompt}</button></div><div className="input-group"><select onChange={(e) => { const found = promptProfiles.find(p => p.id === e.target.value); if (found) setCurrentPrompt({ ...found }); }} value={currentPrompt.id} className="font-bold">{promptProfiles.map(p => <option key={p.id} value={p.id}>{p.name}</option>)}{currentPrompt.id.startsWith('temp_') && <option value={currentPrompt.id}>{currentPrompt.name}</option>}</select></div><textarea value={currentPrompt.content} onChange={e => setCurrentPrompt({ ...currentPrompt, content: e.target.value })} className="w-full h-48 p-3 bg-slate-50 rounded-xl text-[10px] custom-scrollbar border resize-none font-mono" /></div>
                                <div className="bg-white p-5 rounded-[2rem] shadow-xl space-y-4"><h2 className="font-bold border-b pb-2 flex items-center gap-2"><LucideIcon name="sliders" /> {t.commonSettings}</h2><div className="flex gap-2"><div className="input-group flex-1"><label>{t.batchSize}</label><input type="number" value={batchSize} onChange={e => setBatchSize(Number(e.target.value))} className="text-center font-bold" /></div><div className="input-group flex-1"><label>{t.concurrent}</label><input type="number" value={concurrency} onChange={e => setConcurrency(Number(e.target.value))} className="text-center font-bold bg-indigo-50 text-indigo-600 border-indigo-200" /></div></div><div className="input-group"><label>{t.resultDpi}</label><input type="number" value={targetDpi} onChange={e => setTargetDpi(Number(e.target.value))} className="font-bold text-center" step="10" /></div><div className="flex gap-2"><div className="input-group flex-1"><label>{t.pdfDpi}</label><input type="number" value={pdfDpi} onChange={e => setPdfDpi(Number(e.target.value))} className="font-bold text-center bg-indigo-50 text-indigo-600 border-indigo-200" step="10" /></div><div className="input-group flex-1"><label>{t.temperature}</label><input type="number" min="0" max="2" step="0.1" value={aiTemperature} onChange={e => setAiTemperature(parseFloat(e.target.value))} className="font-bold text-center" /></div></div><div className="flex justify-between text-[9px] text-slate-400 font-bold px-1"><span>{t.dpiRecommend}</span><span>{t.tempRange}</span></div><div className="input-group"><label>{t.padding}</label><div className="grid grid-cols-2 gap-2"><div><label>Top</label><input type="number" value={String(paddings.top)} onFocus={e => e.target.select()} onChange={e => setPaddings({ ...paddings, top: Number(e.target.value) })} /></div><div><label>Bottom</label><input type="number" value={String(paddings.bottom)} onFocus={e => e.target.select()} onChange={e => setPaddings({ ...paddings, bottom: Number(e.target.value) })} /></div><div><label>Left</label><input type="number" value={String(paddings.left)} onFocus={e => e.target.select()} onChange={e => setPaddings({ ...paddings, left: Number(e.target.value) })} /></div><div><label>Right</label><input type="number" value={String(paddings.right)} onFocus={e => e.target.select()} onChange={e => setPaddings({ ...paddings, right: Number(e.target.value) })} /></div></div></div><div className="mt-4 border-t pt-2"><div className="flex justify-between items-center mb-2"><span className="text-xs font-bold text-slate-400">{t.log}</span><button onClick={() => setLogs([])} className="text-[10px] text-rose-400">{t.clear}</button></div><div className="h-32 overflow-y-auto custom-scrollbar bg-slate-900 p-2 rounded-lg font-mono text-[10px] leading-relaxed shadow-inner">{[...logs].reverse().map((m, i) => (<div key={i} className={`border-b border-slate-800/50 pb-1 mb-1 break-all ${m.includes('ì—ëŸ¬') ? 'text-rose-400' : m.includes('ì™„ë£Œ') ? 'text-emerald-400' : 'text-indigo-200'}`}>{m}</div>))}</div></div></div>
                            </aside>
                            <main className="lg:col-span-9 space-y-6">
                                <div className="bg-white p-8 rounded-[2rem] shadow-xl min-h-[500px]"><div className="flex flex-wrap justify-between items-center mb-6 gap-4"><h2 className="text-xl font-black italic flex items-center gap-2"><LucideIcon name="images" /> {t.pageGallery}</h2><div className="flex items-center gap-2"><div className="hidden lg:flex items-center gap-1 mr-4 bg-yellow-50 px-2 py-1 rounded border border-yellow-200 text-[10px] text-yellow-700 font-bold"><LucideIcon name="alert-triangle" size={12} /> {t.tips}</div><button onClick={() => setSelectedIds(new Set(pages.map(p => p.id)))} className="text-xs font-bold text-indigo-600 bg-indigo-50 px-3 py-1.5 rounded-lg hover:bg-indigo-100">{t.selectAll}</button><button onClick={() => setSelectedIds(new Set())} className="text-xs font-bold text-slate-500 bg-slate-100 px-3 py-1.5 rounded-lg hover:bg-slate-200">{t.deselect}</button>{selectedIds.size > 0 && <button onClick={() => { if (confirm("ì‚­ì œ?")) { setPages(prev => prev.filter(p => !selectedIds.has(p.id))); setSelectedIds(new Set()); } }} className="text-xs font-bold text-rose-600 bg-rose-50 px-3 py-1.5 rounded-lg">{t.deleteSelected}</button>}<label className="bg-indigo-600 text-white px-6 py-2 rounded-xl text-xs font-bold cursor-pointer hover:bg-indigo-700 shadow-lg shadow-indigo-200 ml-2">{t.uploadPdf} <input type="file" multiple accept="application/pdf" onChange={handlePdf} className="hidden" /></label></div></div><div ref={galleryContainerRef} onScroll={e => setScrollTop(e.target.scrollTop)} className="h-[500px] overflow-y-auto p-4 custom-scrollbar select-none bg-slate-50 rounded-2xl border border-slate-200/60 relative">{!pages.length && !isLoadingPdf && <div className="absolute inset-0 flex flex-col items-center justify-center text-slate-300 italic gap-4"><LucideIcon name="file-up" size={48} /><span>{t.uploadPdfHere}</span></div>}{isLoadingPdf && <div className="absolute inset-0 flex flex-col items-center justify-center text-indigo-600 font-bold z-10 bg-white/80"><LucideIcon name="loader-2" className="animate-spin mb-2" size={32} /> {t.converting}</div>}<div style={{ height: virtualItems.totalHeight }} className="relative w-full">{virtualItems.items.map(pg => (<div key={pg.id} style={pg.style} onMouseDown={e => { e.preventDefault(); setIsDragging(true); setDragStartIndex(pg.originalIndex); setInitialSelectedIds(new Set(selectedIds)); const n = new Set(selectedIds); if (n.has(pg.id)) n.delete(pg.id); else n.add(pg.id); setSelectedIds(n); }} onMouseEnter={() => { if (!isDragging || dragStartIndex === null) return; const currentIdx = pg.originalIndex; const start = Math.min(dragStartIndex, currentIdx); const end = Math.max(dragStartIndex, currentIdx); const n = new Set(initialSelectedIds); for (let i = start; i <= end; i++) n.add(pages[i].id); setSelectedIds(n); }} onDoubleClick={() => { setPreviewImg(pg.thumb); setIsZoomed(false); }} className={`absolute rounded-xl overflow-hidden border-4 transition-all cursor-pointer shadow-sm group bg-white ${selectedIds.has(pg.id) ? 'border-indigo-600 scale-95 ring-4 ring-indigo-100' : 'border-white hover:border-indigo-200'}`}><div className="absolute top-2 right-2 flex gap-1 z-10 opacity-0 group-hover:opacity-100 transition-opacity"><button onClick={(e) => { e.stopPropagation(); handleRetry(pg.pageNum); }} className="bg-emerald-500 text-white p-1 rounded-full hover:scale-110 shadow-sm" title={t.rerun}><LucideIcon name="play" size={12} className={retryingPage === pg.pageNum ? "animate-spin" : ""} /></button><button onClick={(e) => { e.stopPropagation(); setPreviewImg(pg.thumb); setIsZoomed(false); }} className="bg-slate-800/80 text-white p-1 rounded-full hover:scale-110 shadow-sm"><LucideIcon name="maximize-2" size={12} /></button><button onClick={(e) => { e.stopPropagation(); setPages(p => p.filter(x => x.id !== pg.id)); }} className="bg-rose-500 text-white p-1 rounded-full hover:scale-110 shadow-sm"><LucideIcon name="x" size={12} /></button></div><img src={pg.thumb} className="w-full h-full object-cover pointer-events-none" /><div className="absolute top-2 left-2 bg-black/70 backdrop-blur text-white text-[10px] px-2 py-0.5 rounded-full font-bold">p.{pg.pageNum}</div>{selectedIds.has(pg.id) && <div className="absolute inset-0 bg-indigo-600/20 flex items-center justify-center"><LucideIcon name="check-circle" size={32} className="text-indigo-600 bg-white rounded-full p-1 shadow-lg" /></div>}{/* ì™„ë£Œëœ í˜ì´ì§€ í‘œì‹œ */ processedPageNums.has(pg.pageNum) && !selectedIds.has(pg.id) && <div className="absolute inset-0 processed-overlay flex items-center justify-center"><div className="bg-emerald-500 text-white px-3 py-1 rounded-full text-xs font-bold shadow-lg flex items-center gap-1"><LucideIcon name="check" size={14} /> {t.completed}</div></div>}</div>))}</div></div></div>
                                <div className="bg-white p-8 rounded-[2rem] shadow-xl h-[850px] flex flex-col relative"><div className="flex justify-between items-center mb-6 flex-shrink-0"><div className="flex items-center gap-4"><h2 className="text-xl font-black italic flex items-center gap-2"><LucideIcon name="layers" /> {t.result}</h2><div className="relative group"><LucideIcon name="search" size={14} className="absolute left-3 top-1/2 -translate-y-1/2 text-slate-400 group-focus-within:text-indigo-500 transition-colors" /><input type="text" value={searchTerm} onChange={e => setSearchTerm(e.target.value)} placeholder={t.search} className="pl-9 pr-8 py-1.5 rounded-full border border-slate-200 text-xs font-bold bg-slate-50 focus:bg-white focus:outline-none focus:ring-2 focus:ring-indigo-100 w-52 transition-all shadow-sm" />{searchTerm && <button onClick={() => setSearchTerm('')} className="absolute right-2 top-1/2 -translate-y-1/2 text-slate-400 hover:text-rose-500"><LucideIcon name="x" size={14} /></button>}{searchTerm && <div className="absolute left-0 -bottom-5 text-[10px] text-indigo-500 font-bold ml-2">{filteredResults.reduce((acc, p) => acc + p.items.length, 0)}{t.found}</div>}</div><button onClick={() => setShowRegexModal(true)} className="bg-violet-50 text-violet-600 border border-violet-200 px-2 py-1.5 rounded-lg text-xs font-bold flex items-center gap-1 hover:bg-violet-100" title={t.regexSettings}><LucideIcon name="regex" size={14} /> {t.regex}({regexPatterns.filter(r => r.enabled).length})</button></div><div className="flex items-center gap-2"><button onClick={selectAllResult} disabled={results.length === 0} className="text-xs font-bold text-indigo-600 bg-indigo-50 px-3 py-1.5 rounded-lg hover:bg-indigo-100">{t.selectAll}</button><button onClick={deselectAllResult} disabled={results.length === 0} className="text-xs font-bold text-slate-500 bg-slate-100 px-3 py-1.5 rounded-lg hover:bg-slate-200">{t.deselect}</button>{selectedResultIds.size > 0 ? <button onClick={deleteSelectedResult} className="text-xs font-bold text-rose-600 bg-rose-50 px-3 py-1.5 rounded-lg hover:bg-rose-100">{t.deleteSelected} ({selectedResultIds.size})</button> : <button onClick={handleFullReset} disabled={results.length === 0} className="text-xs font-bold text-rose-600 bg-rose-50 px-3 py-1.5 rounded-lg hover:bg-rose-100">{t.reset}</button>}<div className="w-px h-4 bg-slate-200 mx-2"></div><button onClick={() => setShowFieldsModal(true)} className="bg-slate-100 text-slate-600 px-3 py-2 rounded-xl text-xs font-bold flex items-center gap-1 hover:bg-slate-200" title={t.fieldSettings}><LucideIcon name="table" size={14} /> {t.fields}({ankiFields.filter(f => f.enabled).length})</button><button onClick={downloadZip} disabled={results.length === 0} className="bg-emerald-500 text-white px-6 py-2 rounded-xl text-xs font-bold shadow-lg shadow-emerald-100 flex items-center gap-2 hover:bg-emerald-600"><LucideIcon name="download" size={16} /> {t.zipDownload}</button></div></div><div className="space-y-4 flex-1 overflow-y-auto custom-scrollbar select-text bg-slate-50 p-6 rounded-2xl border border-slate-200 mb-2">{filteredResults.length === 0 ? <div className="py-20 text-center text-slate-300 italic flex flex-col items-center gap-2"><LucideIcon name="search" size={32} />{searchTerm ? t.noSearchResults : t.noResults}</div> : filteredResults.slice(resultPage * ITEMS_PER_PAGE, (resultPage + 1) * ITEMS_PER_PAGE).map((pageResult, pIdx) => (<div key={pageResult.pageNum} className="space-y-2 mb-8"><div className="flex items-center gap-2"><div className="text-xs font-bold text-slate-400 ml-2 uppercase tracking-wider">Page {pageResult.pageNum}</div><button onClick={() => handleRetry(pageResult.pageNum)} disabled={retryingPage === pageResult.pageNum} className="flex items-center gap-1 text-[10px] px-2 py-1 bg-indigo-50 text-indigo-600 rounded hover:bg-indigo-100 transition-colors disabled:opacity-50"><LucideIcon name="refresh-cw" size={10} className={retryingPage === pageResult.pageNum ? "animate-spin" : ""} /> {t.rerun}</button></div><div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">{pageResult.items.map((it, iIdx) => (<ResultItem key={it.fName} item={it} pageNum={pageResult.pageNum} isSelected={selectedResultIds.has(it.fName)} isEditing={editingItem && editingItem.pageNum === pageResult.pageNum && editingItem.itemIdx === (it.originalItemIndex ?? iIdx)} isLoading={loadingEditId === `${pageResult.pageNum}-${it.originalItemIndex ?? iIdx}`} tempImg={editingItem?.tempImg} onToggleSelect={toggleSelectResult} onStartEdit={startEditing} onUpdateBbox={updateEditBbox} onEndEdit={endEditing} onDelete={handleDeleteItem} onPreview={handlePreview} />))}</div></div>))}
                                    {filteredResults.length > ITEMS_PER_PAGE && (
                                        <div className="flex justify-between items-center bg-white p-2 border-t border-slate-100 flex-shrink-0 mt-2">
                                            <button
                                                onClick={() => setResultPage(Math.max(0, resultPage - 1))}
                                                disabled={resultPage === 0}
                                                className="px-4 py-2 bg-slate-50 border border-slate-200 rounded-lg text-sm font-bold text-slate-600 hover:bg-slate-100 disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-1"
                                            >
                                                <LucideIcon name="chevron-left" size={16} /> {t.prev}
                                            </button>

                                            <div className="flex items-center gap-2 bg-slate-50 px-4 py-2 rounded-lg border border-slate-200">
                                                <span className="text-xs font-bold text-slate-400">Page</span>
                                                <input
                                                    type="number"
                                                    min="1"
                                                    max={Math.ceil(filteredResults.length / ITEMS_PER_PAGE)}
                                                    value={tempPageInput}
                                                    onFocus={(e) => e.target.select()}
                                                    onChange={(e) => setTempPageInput(e.target.value)}
                                                    onKeyDown={(e) => { if (e.key === 'Enter') applyPageInput(); }}
                                                    onBlur={applyPageInput}
                                                    className="w-12 text-center bg-white border border-slate-300 rounded text-sm font-bold text-indigo-600 focus:outline-none focus:border-indigo-500"
                                                />
                                                <span className="text-xs font-bold text-slate-400">/ {Math.ceil(filteredResults.length / ITEMS_PER_PAGE)}</span>
                                            </div>

                                            <button
                                                onClick={() => setResultPage(Math.min(Math.ceil(filteredResults.length / ITEMS_PER_PAGE) - 1, resultPage + 1))}
                                                disabled={resultPage >= Math.ceil(filteredResults.length / ITEMS_PER_PAGE) - 1}
                                                className="px-4 py-2 bg-slate-50 border border-slate-200 rounded-lg text-sm font-bold text-slate-600 hover:bg-slate-100 disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-1"
                                            >
                                                {t.next} <LucideIcon name="chevron-right" size={16} />
                                            </button>
                                        </div>
                                    )}</div></div>
                            </main>
                        </div>
                        {/* Anki í•„ë“œ ì„¤ì • ëª¨ë‹¬ */}
                        {showFieldsModal && (
                            <div className="fixed inset-0 z-50 bg-black/50 flex items-center justify-center modal-overlay" onClick={() => setShowFieldsModal(false)}>
                                <div className="bg-white rounded-2xl shadow-2xl p-6 w-full max-w-lg max-h-[80vh] overflow-y-auto" onClick={(e) => e.stopPropagation()}>
                                    <div className="flex justify-between items-center mb-4 border-b pb-3">
                                        <h3 className="text-lg font-black flex items-center gap-2">
                                            <LucideIcon name="table" size={20} /> {t.fieldModalTitle}
                                        </h3>
                                        <button onClick={() => setShowFieldsModal(false)} className="text-slate-400 hover:text-slate-600">
                                            <LucideIcon name="x" size={20} />
                                        </button>
                                    </div>

                                    <p className="text-xs text-slate-500 mb-4">
                                        {t.fieldModalDesc}
                                    </p>

                                    <div className="space-y-2 mb-4">
                                        {ankiFields.map((field, idx) => (
                                            <div key={field.id} className={`flex items-center gap-2 p-3 rounded-xl border ${field.enabled ? 'bg-white border-indigo-200' : 'bg-slate-50 border-slate-200 opacity-60'}`}>
                                                <button
                                                    onClick={() => {
                                                        const newFields = [...ankiFields];
                                                        newFields[idx] = { ...field, enabled: !field.enabled };
                                                        setAnkiFields(newFields);
                                                    }}
                                                    className={`w-5 h-5 rounded flex items-center justify-center flex-shrink-0 ${field.enabled ? 'bg-indigo-600 text-white' : 'bg-slate-200 border border-slate-300'}`}
                                                >
                                                    <LucideIcon name="check" size={12} className={field.enabled ? '' : 'opacity-0'} />
                                                </button>

                                                <input
                                                    type="text"
                                                    value={field.name}
                                                    onChange={(e) => {
                                                        const newFields = [...ankiFields];
                                                        newFields[idx] = { ...field, name: e.target.value };
                                                        setAnkiFields(newFields);
                                                    }}
                                                    className="flex-1 text-sm font-bold border-0 bg-transparent focus:outline-none"
                                                />

                                                <select
                                                    value={field.type}
                                                    onChange={(e) => {
                                                        const newFields = [...ankiFields];
                                                        const newType = e.target.value;
                                                        newFields[idx] = {
                                                            ...field,
                                                            type: newType,
                                                            isImage: ['question', 'solution'].includes(newType)
                                                        };
                                                        setAnkiFields(newFields);
                                                    }}
                                                    className="text-xs bg-slate-100 border-0 rounded px-2 py-1"
                                                >
                                                    <option value="question">{t.questionImg}</option>
                                                    <option value="solution">{t.solutionImg}</option>
                                                    <option value="tag">{t.chapterTag}</option>
                                                    <option value="custom">{t.customField}</option>
                                                </select>

                                                <button
                                                    onClick={() => {
                                                        if (ankiFields.length <= 1) return;
                                                        setAnkiFields(ankiFields.filter((_, i) => i !== idx));
                                                    }}
                                                    className="text-slate-300 hover:text-rose-500"
                                                >
                                                    <LucideIcon name="trash-2" size={14} />
                                                </button>
                                            </div>
                                        ))}
                                    </div>

                                    <button
                                        onClick={() => {
                                            setAnkiFields([...ankiFields, {
                                                id: `custom_${Date.now()}`,
                                                name: 'ìƒˆ í•„ë“œ',
                                                type: 'custom',
                                                enabled: true,
                                                isImage: false,
                                                defaultValue: ''
                                            }]);
                                        }}
                                        className="w-full py-2 border-2 border-dashed border-slate-200 rounded-xl text-slate-400 hover:border-indigo-400 hover:text-indigo-500 text-sm font-bold flex items-center justify-center gap-2"
                                    >
                                        <LucideIcon name="plus" size={16} /> {t.addField}
                                    </button>

                                    <div className="mt-4 pt-4 border-t flex justify-between">
                                        <button
                                            onClick={() => setAnkiFields(DEFAULT_ANKI_FIELDS)}
                                            className="text-xs text-slate-500 hover:text-slate-700"
                                        >
                                            {t.resetDefault}
                                        </button>
                                        <button
                                            onClick={() => setShowFieldsModal(false)}
                                            className="bg-indigo-600 text-white px-6 py-2 rounded-xl text-sm font-bold hover:bg-indigo-700"
                                        >
                                            {t.done}
                                        </button>
                                    </div>
                                </div>
                            </div>
                        )}
                        {/* ì •ê·œì‹ ì„¤ì • ëª¨ë‹¬ */}
                        {showRegexModal && (
                            <div className="fixed inset-0 z-50 bg-black/50 flex items-center justify-center modal-overlay" onClick={() => setShowRegexModal(false)}>
                                <div className="bg-white rounded-2xl shadow-2xl p-6 w-full max-w-lg max-h-[80vh] overflow-y-auto" onClick={(e) => e.stopPropagation()}>
                                    <div className="flex justify-between items-center mb-4 border-b pb-3">
                                        <h3 className="text-lg font-black flex items-center gap-2">
                                            <LucideIcon name="regex" size={20} /> {t.regexSettings}
                                        </h3>
                                        <button onClick={() => setShowRegexModal(false)} className="text-slate-400 hover:text-slate-600">
                                            <LucideIcon name="x" size={20} />
                                        </button>
                                    </div>

                                    <p className="text-xs text-slate-500 mb-4">
                                        {t.regexDesc}
                                    </p>

                                    <div className="space-y-2 mb-4">
                                        {regexPatterns.map((pattern, idx) => (
                                            <div key={pattern.id} className={`flex flex-col gap-2 p-3 rounded-xl border ${pattern.enabled ? 'bg-white border-violet-200' : 'bg-slate-50 border-slate-200 opacity-60'}`}>
                                                <div className="flex items-center gap-2">
                                                    <button
                                                        onClick={() => {
                                                            const newPatterns = [...regexPatterns];
                                                            newPatterns[idx] = { ...pattern, enabled: !pattern.enabled };
                                                            setRegexPatterns(newPatterns);
                                                        }}
                                                        className={`w-5 h-5 rounded flex items-center justify-center ${pattern.enabled ? 'bg-violet-600 text-white' : 'bg-slate-200'}`}
                                                    >
                                                        {pattern.enabled && <LucideIcon name="check" size={12} />}
                                                    </button>

                                                    <input
                                                        type="text"
                                                        value={pattern.name}
                                                        onChange={(e) => {
                                                            const newPatterns = [...regexPatterns];
                                                            newPatterns[idx] = { ...pattern, name: e.target.value };
                                                            setRegexPatterns(newPatterns);
                                                        }}
                                                        placeholder={t.regexName}
                                                        className="flex-1 text-sm font-bold border border-slate-200 rounded px-2 py-1 bg-slate-50 focus:outline-none focus:border-violet-400"
                                                    />

                                                    <button
                                                        onClick={() => {
                                                            setRegexPatterns(regexPatterns.filter((_, i) => i !== idx));
                                                        }}
                                                        className="text-slate-300 hover:text-rose-500"
                                                    >
                                                        <LucideIcon name="trash-2" size={14} />
                                                    </button>
                                                </div>
                                                <input
                                                    type="text"
                                                    value={pattern.regex}
                                                    onChange={(e) => {
                                                        const newPatterns = [...regexPatterns];
                                                        newPatterns[idx] = { ...pattern, regex: e.target.value };
                                                        setRegexPatterns(newPatterns);
                                                    }}
                                                    placeholder={t.regexPattern}
                                                    className="w-full text-xs font-mono border border-slate-200 rounded px-2 py-1.5 bg-slate-50 focus:outline-none focus:border-violet-400"
                                                />
                                            </div>
                                        ))}
                                    </div>

                                    {regexPatterns.length === 0 && (
                                        <div className="py-8 text-center text-slate-300 italic text-sm">
                                            {language === 'ko' ? 'ì •ê·œì‹ íŒ¨í„´ì´ ì—†ìŠµë‹ˆë‹¤. ì•„ë˜ ë²„íŠ¼ìœ¼ë¡œ ì¶”ê°€í•˜ì„¸ìš”.' : language === 'zh' ? 'æ²¡æœ‰æ­£åˆ™è¡¨è¾¾å¼æ¨¡å¼ã€‚ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®æ·»åŠ ã€‚' : 'No regex patterns. Click below to add.'}
                                        </div>
                                    )}

                                    <button
                                        onClick={() => {
                                            setRegexPatterns([...regexPatterns, {
                                                id: `regex_${Date.now()}`,
                                                name: '',
                                                regex: '',
                                                enabled: true
                                            }]);
                                        }}
                                        className="w-full py-2 border-2 border-dashed border-slate-200 rounded-xl text-slate-400 hover:border-violet-400 hover:text-violet-500 text-sm font-bold flex items-center justify-center gap-2"
                                    >
                                        <LucideIcon name="plus" size={16} /> {t.addRegex}
                                    </button>

                                    <div className="mt-4 p-3 bg-slate-50 rounded-xl text-[10px] text-slate-500">
                                        <div className="font-bold mb-1">{language === 'ko' ? 'ì˜ˆì‹œ' : language === 'zh' ? 'ç¤ºä¾‹' : 'Example'}:</div>
                                        <div className="font-mono">^ì œ[\s_]*(\d+)[\s_]*([í¸ì¥ê°•])</div>
                                        <div className="mt-1 text-slate-400">{language === 'ko' ? 'â†’ "ì œ_1_í¸ í–‰ì •ë²•" â†’ "1í¸"' : language === 'zh' ? 'â†’ "ç¬¬_1_ç«  è¡Œæ”¿æ³•" â†’ "1ç« "' : 'â†’ "Chapter_1_" â†’ "1"'}</div>
                                    </div>

                                    <div className="mt-4 pt-4 border-t flex justify-end">
                                        <button
                                            onClick={() => setShowRegexModal(false)}
                                            className="bg-violet-600 text-white px-6 py-2 rounded-xl text-sm font-bold hover:bg-violet-700"
                                        >
                                            {t.done}
                                        </button>
                                    </div>
                                </div>
                            </div>
                        )}
                        {previewImg && (<div className="fixed inset-0 z-50 bg-black/95 flex items-center justify-center modal-overlay" onClick={() => { setPreviewImg(null); setIsZoomed(false); }}><button className="absolute top-6 right-6 text-white/70 hover:text-white transition-colors p-2 bg-white/10 rounded-full z-50"><LucideIcon name="x" size={32} /></button><div className="w-full h-full flex items-center justify-center overflow-auto" onClick={e => { if (e.target === e.currentTarget) { setPreviewImg(null); setIsZoomed(false); } }}><img src={previewImg} className={`transition-all duration-300 ease-out shadow-2xl ${isZoomed ? 'cursor-zoom-out' : 'cursor-zoom-in'}`} style={{ transform: isZoomed ? 'scale(2.5)' : 'scale(1)', maxWidth: isZoomed ? 'none' : '90vw', maxHeight: isZoomed ? 'none' : '90vh' }} onClick={(e) => { e.stopPropagation(); setIsZoomed(!isZoomed); }} /></div></div>)}
                    </div>
                </ErrorBoundary>
            );
        };
        const root = ReactDOM.createRoot(document.getElementById('root')); root.render(<App />);
    </script>
</body>

</html>